__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_PACKEDMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_PACKEDMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_METALGLOSSMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_METALGLOSSMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define FLIP_SIDED
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
    uniform vec4 offsetRepeat;
#endif

#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
#endif
#ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        varying vec3 vWorldPosition;
    #else
        varying vec3 vReflect;
        uniform float refractionRatio;
    #endif
#endif

#ifdef USE_COLOR
    varying vec3 vColor;
#endif
#ifdef USE_MORPHTARGETS
    #ifndef USE_MORPHNORMALS
    uniform float morphTargetInfluences[ 8 ];
    #else
    uniform float morphTargetInfluences[ 4 ];
    #endif
#endif
#ifdef USE_SKINNING
    uniform mat4 bindMatrix;
    uniform mat4 bindMatrixInverse;
    #ifdef BONE_TEXTURE
        uniform sampler2D boneTexture;
        uniform int boneTextureWidth;
        uniform int boneTextureHeight;
        mat4 getBoneMatrix( const in float i ) {
            float j = i * 4.0;
            float x = mod( j, float( boneTextureWidth ) );
            float y = floor( j / float( boneTextureWidth ) );
            float dx = 1.0 / float( boneTextureWidth );
            float dy = 1.0 / float( boneTextureHeight );
            y = dy * ( y + 0.5 );
            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
            mat4 bone = mat4( v1, v2, v3, v4 );
            return bone;
        }
    #else
        uniform mat4 boneMatrices[ MAX_BONES ];
        mat4 getBoneMatrix( const in float i ) {
            mat4 bone = boneMatrices[ int(i) ];
            return bone;
        }
    #endif
#endif

#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
    uniform float logDepthBufFC;
#endif
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    varying vec3 vViewPosition;
#endif

void main() {
    #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
#endif
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    vUv2 = uv2;
#endif
    #ifdef USE_COLOR
    vColor.xyz = color.xyz;
#endif
    #ifdef USE_SKINNING
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif
    #ifdef USE_ENVMAP
    
vec3 objectNormal = vec3( normal );

    #ifdef USE_MORPHNORMALS
    objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
    objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
    objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
    objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif

    #ifdef USE_SKINNING
    mat4 skinMatrix = mat4( 0.0 );
    skinMatrix += skinWeight.x * boneMatX;
    skinMatrix += skinWeight.y * boneMatY;
    skinMatrix += skinWeight.z * boneMatZ;
    skinMatrix += skinWeight.w * boneMatW;
    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif

    #ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif
vec3 transformedNormal = normalMatrix * objectNormal;

    #endif
    
vec3 transformed = vec3( position );

    #ifdef USE_MORPHTARGETS
    transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
    transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
    transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
    transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
    #ifndef USE_MORPHNORMALS
    transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
    transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
    transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
    transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
    #endif
#endif

    #ifdef USE_SKINNING
    vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned  = bindMatrixInverse * skinned;
#endif

    #ifdef USE_SKINNING
    vec4 mvPosition = modelViewMatrix * skinned;
#else
    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
#endif
gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_LOGDEPTHBUF
    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
    #else
        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
    #endif
#endif

    #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
    #ifdef USE_SKINNING
        vec4 worldPosition = modelMatrix * skinned;
    #else
        vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
    #endif
#endif

    #if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    vViewPosition = - mvPosition.xyz;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vWorldPosition = worldPosition.xyz;
    #else
        vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vReflect = reflect( cameraToVertex, worldNormal );
        #else
            vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #endif
#endif

}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define GAMMA_FACTOR 2
#define FLIP_SIDED
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
    varying vec3 vNormal;
#endif
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_COLOR
    varying vec3 vColor;
#endif

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
#endif
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
#endif
#ifdef USE_MAP
    uniform sampler2D map;
#endif

#ifdef USE_ALPHAMAP
    uniform sampler2D alphaMap;
#endif

#ifdef USE_AOMAP
    uniform sampler2D aoMap;
    uniform float aoMapIntensity;
#endif
#if defined( USE_ENVMAP ) || defined( PHYSICAL )
    uniform float reflectivity;
    uniform float envMapIntenstiy;
#endif
#ifdef USE_ENVMAP
    #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
        varying vec3 vWorldPosition;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        uniform samplerCube envMap;
    #else
        uniform sampler2D envMap;
    #endif
    uniform float flipEnvMap;
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
        uniform float refractionRatio;
    #else
        varying vec3 vReflect;
    #endif
#endif

#ifdef USE_FOG
    uniform vec3 fogColor;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif
#ifdef USE_SPECULARMAP
    uniform sampler2D specularMap;
#endif
#ifdef USE_LOGDEPTHBUF
    uniform float logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
#endif

#if NUM_CLIPPING_PLANES > 0
    #if ! defined( PHYSICAL ) && ! defined( PHONG )
        varying vec3 vViewPosition;
    #endif
    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif

void main() {
    #if NUM_CLIPPING_PLANES > 0
    for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {
        vec4 plane = clippingPlanes[ i ];
        if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
    }
#endif

    vec4 diffuseColor = vec4( diffuse, opacity );
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
    #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif

    #ifdef USE_COLOR
    diffuseColor.rgb *= vColor;
#endif
    #ifdef USE_ALPHAMAP
    diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif

    #ifdef ALPHATEST
    if ( diffuseColor.a < ALPHATEST ) discard;
#endif

    float specularStrength;
#ifdef USE_SPECULARMAP
    vec4 texelSpecular = texture2D( specularMap, vUv );
    specularStrength = texelSpecular.r;
#else
    specularStrength = 1.0;
#endif
    ReflectedLight reflectedLight;
    reflectedLight.directDiffuse = vec3( 0.0 );
    reflectedLight.directSpecular = vec3( 0.0 );
    reflectedLight.indirectDiffuse = diffuseColor.rgb;
    reflectedLight.indirectSpecular = vec3( 0.0 );
    #ifdef USE_AOMAP
    float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
    reflectedLight.indirectDiffuse *= ambientOcclusion;
    #if defined( USE_ENVMAP ) && defined( PHYSICAL )
        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
    #endif
#endif

    vec3 outgoingLight = reflectedLight.indirectDiffuse;
    #ifdef DOUBLE_SIDED
    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
#else
    float flipNormal = 1.0;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vec3 reflectVec = reflect( cameraToVertex, worldNormal );
        #else
            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #else
        vec3 reflectVec = vReflect;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #elif defined( ENVMAP_TYPE_EQUIREC )
        vec2 sampleUV;
        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );
        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
        vec4 envColor = texture2D( envMap, sampleUV );
    #elif defined( ENVMAP_TYPE_SPHERE )
        vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
    #endif
    envColor = envMapTexelToLinear( envColor );
    #ifdef ENVMAP_BLENDING_MULTIPLY
        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_MIX )
        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_ADD )
        outgoingLight += envColor.xyz * specularStrength * reflectivity;
    #endif
#endif

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #ifdef PREMULTIPLIED_ALPHA
    gl_FragColor.rgb *= gl_FragColor.a;
#endif

    #if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif

      gl_FragColor = linearToOutputTexel( gl_FragColor );

    #ifdef USE_FOG
    #ifdef USE_LOGDEPTHBUF_EXT
        float depth = gl_FragDepthEXT / gl_FragCoord.w;
    #else
        float depth = gl_FragCoord.z / gl_FragCoord.w;
    #endif
    #ifdef FOG_EXP2
        float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif

}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_PACKEDMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_PACKEDMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_NORMALMAP true
#define USE_METALGLOSSMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_NORMALMAP true
#define USE_METALGLOSSMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define USE_MAP
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
    uniform vec4 offsetRepeat;
#endif

#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
#endif
#ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        varying vec3 vWorldPosition;
    #else
        varying vec3 vReflect;
        uniform float refractionRatio;
    #endif
#endif

#ifdef USE_COLOR
    varying vec3 vColor;
#endif
#ifdef USE_MORPHTARGETS
    #ifndef USE_MORPHNORMALS
    uniform float morphTargetInfluences[ 8 ];
    #else
    uniform float morphTargetInfluences[ 4 ];
    #endif
#endif
#ifdef USE_SKINNING
    uniform mat4 bindMatrix;
    uniform mat4 bindMatrixInverse;
    #ifdef BONE_TEXTURE
        uniform sampler2D boneTexture;
        uniform int boneTextureWidth;
        uniform int boneTextureHeight;
        mat4 getBoneMatrix( const in float i ) {
            float j = i * 4.0;
            float x = mod( j, float( boneTextureWidth ) );
            float y = floor( j / float( boneTextureWidth ) );
            float dx = 1.0 / float( boneTextureWidth );
            float dy = 1.0 / float( boneTextureHeight );
            y = dy * ( y + 0.5 );
            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
            mat4 bone = mat4( v1, v2, v3, v4 );
            return bone;
        }
    #else
        uniform mat4 boneMatrices[ MAX_BONES ];
        mat4 getBoneMatrix( const in float i ) {
            mat4 bone = boneMatrices[ int(i) ];
            return bone;
        }
    #endif
#endif

#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
    uniform float logDepthBufFC;
#endif
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    varying vec3 vViewPosition;
#endif

void main() {
    #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
#endif
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    vUv2 = uv2;
#endif
    #ifdef USE_COLOR
    vColor.xyz = color.xyz;
#endif
    #ifdef USE_SKINNING
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif
    #ifdef USE_ENVMAP
    
vec3 objectNormal = vec3( normal );

    #ifdef USE_MORPHNORMALS
    objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
    objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
    objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
    objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif

    #ifdef USE_SKINNING
    mat4 skinMatrix = mat4( 0.0 );
    skinMatrix += skinWeight.x * boneMatX;
    skinMatrix += skinWeight.y * boneMatY;
    skinMatrix += skinWeight.z * boneMatZ;
    skinMatrix += skinWeight.w * boneMatW;
    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif

    #ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif
vec3 transformedNormal = normalMatrix * objectNormal;

    #endif
    
vec3 transformed = vec3( position );

    #ifdef USE_MORPHTARGETS
    transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
    transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
    transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
    transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
    #ifndef USE_MORPHNORMALS
    transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
    transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
    transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
    transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
    #endif
#endif

    #ifdef USE_SKINNING
    vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned  = bindMatrixInverse * skinned;
#endif

    #ifdef USE_SKINNING
    vec4 mvPosition = modelViewMatrix * skinned;
#else
    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
#endif
gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_LOGDEPTHBUF
    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
    #else
        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
    #endif
#endif

    #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
    #ifdef USE_SKINNING
        vec4 worldPosition = modelMatrix * skinned;
    #else
        vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
    #endif
#endif

    #if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    vViewPosition = - mvPosition.xyz;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vWorldPosition = worldPosition.xyz;
    #else
        vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vReflect = reflect( cameraToVertex, worldNormal );
        #else
            vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #endif
#endif

}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define GAMMA_FACTOR 2
#define USE_MAP
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
    varying vec3 vNormal;
#endif
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_COLOR
    varying vec3 vColor;
#endif

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
#endif
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
#endif
#ifdef USE_MAP
    uniform sampler2D map;
#endif

#ifdef USE_ALPHAMAP
    uniform sampler2D alphaMap;
#endif

#ifdef USE_AOMAP
    uniform sampler2D aoMap;
    uniform float aoMapIntensity;
#endif
#if defined( USE_ENVMAP ) || defined( PHYSICAL )
    uniform float reflectivity;
    uniform float envMapIntenstiy;
#endif
#ifdef USE_ENVMAP
    #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
        varying vec3 vWorldPosition;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        uniform samplerCube envMap;
    #else
        uniform sampler2D envMap;
    #endif
    uniform float flipEnvMap;
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
        uniform float refractionRatio;
    #else
        varying vec3 vReflect;
    #endif
#endif

#ifdef USE_FOG
    uniform vec3 fogColor;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif
#ifdef USE_SPECULARMAP
    uniform sampler2D specularMap;
#endif
#ifdef USE_LOGDEPTHBUF
    uniform float logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
#endif

#if NUM_CLIPPING_PLANES > 0
    #if ! defined( PHYSICAL ) && ! defined( PHONG )
        varying vec3 vViewPosition;
    #endif
    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif

void main() {
    #if NUM_CLIPPING_PLANES > 0
    for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {
        vec4 plane = clippingPlanes[ i ];
        if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
    }
#endif

    vec4 diffuseColor = vec4( diffuse, opacity );
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
    #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif

    #ifdef USE_COLOR
    diffuseColor.rgb *= vColor;
#endif
    #ifdef USE_ALPHAMAP
    diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif

    #ifdef ALPHATEST
    if ( diffuseColor.a < ALPHATEST ) discard;
#endif

    float specularStrength;
#ifdef USE_SPECULARMAP
    vec4 texelSpecular = texture2D( specularMap, vUv );
    specularStrength = texelSpecular.r;
#else
    specularStrength = 1.0;
#endif
    ReflectedLight reflectedLight;
    reflectedLight.directDiffuse = vec3( 0.0 );
    reflectedLight.directSpecular = vec3( 0.0 );
    reflectedLight.indirectDiffuse = diffuseColor.rgb;
    reflectedLight.indirectSpecular = vec3( 0.0 );
    #ifdef USE_AOMAP
    float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
    reflectedLight.indirectDiffuse *= ambientOcclusion;
    #if defined( USE_ENVMAP ) && defined( PHYSICAL )
        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
    #endif
#endif

    vec3 outgoingLight = reflectedLight.indirectDiffuse;
    #ifdef DOUBLE_SIDED
    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
#else
    float flipNormal = 1.0;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vec3 reflectVec = reflect( cameraToVertex, worldNormal );
        #else
            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #else
        vec3 reflectVec = vReflect;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #elif defined( ENVMAP_TYPE_EQUIREC )
        vec2 sampleUV;
        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );
        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
        vec4 envColor = texture2D( envMap, sampleUV );
    #elif defined( ENVMAP_TYPE_SPHERE )
        vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
    #endif
    envColor = envMapTexelToLinear( envColor );
    #ifdef ENVMAP_BLENDING_MULTIPLY
        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_MIX )
        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_ADD )
        outgoingLight += envColor.xyz * specularStrength * reflectivity;
    #endif
#endif

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #ifdef PREMULTIPLIED_ALPHA
    gl_FragColor.rgb *= gl_FragColor.a;
#endif

    #if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif

      gl_FragColor = linearToOutputTexel( gl_FragColor );

    #ifdef USE_FOG
    #ifdef USE_LOGDEPTHBUF_EXT
        float depth = gl_FragDepthEXT / gl_FragCoord.w;
    #else
        float depth = gl_FragCoord.z / gl_FragCoord.w;
    #endif
    #ifdef FOG_EXP2
        float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif

}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
    uniform vec4 offsetRepeat;
#endif

#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
#endif
#ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        varying vec3 vWorldPosition;
    #else
        varying vec3 vReflect;
        uniform float refractionRatio;
    #endif
#endif

#ifdef USE_COLOR
    varying vec3 vColor;
#endif
#ifdef USE_MORPHTARGETS
    #ifndef USE_MORPHNORMALS
    uniform float morphTargetInfluences[ 8 ];
    #else
    uniform float morphTargetInfluences[ 4 ];
    #endif
#endif
#ifdef USE_SKINNING
    uniform mat4 bindMatrix;
    uniform mat4 bindMatrixInverse;
    #ifdef BONE_TEXTURE
        uniform sampler2D boneTexture;
        uniform int boneTextureWidth;
        uniform int boneTextureHeight;
        mat4 getBoneMatrix( const in float i ) {
            float j = i * 4.0;
            float x = mod( j, float( boneTextureWidth ) );
            float y = floor( j / float( boneTextureWidth ) );
            float dx = 1.0 / float( boneTextureWidth );
            float dy = 1.0 / float( boneTextureHeight );
            y = dy * ( y + 0.5 );
            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
            mat4 bone = mat4( v1, v2, v3, v4 );
            return bone;
        }
    #else
        uniform mat4 boneMatrices[ MAX_BONES ];
        mat4 getBoneMatrix( const in float i ) {
            mat4 bone = boneMatrices[ int(i) ];
            return bone;
        }
    #endif
#endif

#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
    uniform float logDepthBufFC;
#endif
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    varying vec3 vViewPosition;
#endif

void main() {
    #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
#endif
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    vUv2 = uv2;
#endif
    #ifdef USE_COLOR
    vColor.xyz = color.xyz;
#endif
    #ifdef USE_SKINNING
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif
    #ifdef USE_ENVMAP
    
vec3 objectNormal = vec3( normal );

    #ifdef USE_MORPHNORMALS
    objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
    objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
    objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
    objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif

    #ifdef USE_SKINNING
    mat4 skinMatrix = mat4( 0.0 );
    skinMatrix += skinWeight.x * boneMatX;
    skinMatrix += skinWeight.y * boneMatY;
    skinMatrix += skinWeight.z * boneMatZ;
    skinMatrix += skinWeight.w * boneMatW;
    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif

    #ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif
vec3 transformedNormal = normalMatrix * objectNormal;

    #endif
    
vec3 transformed = vec3( position );

    #ifdef USE_MORPHTARGETS
    transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
    transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
    transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
    transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
    #ifndef USE_MORPHNORMALS
    transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
    transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
    transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
    transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
    #endif
#endif

    #ifdef USE_SKINNING
    vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned  = bindMatrixInverse * skinned;
#endif

    #ifdef USE_SKINNING
    vec4 mvPosition = modelViewMatrix * skinned;
#else
    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
#endif
gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_LOGDEPTHBUF
    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
    #else
        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
    #endif
#endif

    #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
    #ifdef USE_SKINNING
        vec4 worldPosition = modelMatrix * skinned;
    #else
        vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
    #endif
#endif

    #if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    vViewPosition = - mvPosition.xyz;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vWorldPosition = worldPosition.xyz;
    #else
        vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vReflect = reflect( cameraToVertex, worldNormal );
        #else
            vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #endif
#endif

}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define GAMMA_FACTOR 2
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
    varying vec3 vNormal;
#endif
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_COLOR
    varying vec3 vColor;
#endif

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
#endif
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
#endif
#ifdef USE_MAP
    uniform sampler2D map;
#endif

#ifdef USE_ALPHAMAP
    uniform sampler2D alphaMap;
#endif

#ifdef USE_AOMAP
    uniform sampler2D aoMap;
    uniform float aoMapIntensity;
#endif
#if defined( USE_ENVMAP ) || defined( PHYSICAL )
    uniform float reflectivity;
    uniform float envMapIntenstiy;
#endif
#ifdef USE_ENVMAP
    #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
        varying vec3 vWorldPosition;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        uniform samplerCube envMap;
    #else
        uniform sampler2D envMap;
    #endif
    uniform float flipEnvMap;
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
        uniform float refractionRatio;
    #else
        varying vec3 vReflect;
    #endif
#endif

#ifdef USE_FOG
    uniform vec3 fogColor;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif
#ifdef USE_SPECULARMAP
    uniform sampler2D specularMap;
#endif
#ifdef USE_LOGDEPTHBUF
    uniform float logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
#endif

#if NUM_CLIPPING_PLANES > 0
    #if ! defined( PHYSICAL ) && ! defined( PHONG )
        varying vec3 vViewPosition;
    #endif
    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif

void main() {
    #if NUM_CLIPPING_PLANES > 0
    for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {
        vec4 plane = clippingPlanes[ i ];
        if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
    }
#endif

    vec4 diffuseColor = vec4( diffuse, opacity );
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
    #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif

    #ifdef USE_COLOR
    diffuseColor.rgb *= vColor;
#endif
    #ifdef USE_ALPHAMAP
    diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif

    #ifdef ALPHATEST
    if ( diffuseColor.a < ALPHATEST ) discard;
#endif

    float specularStrength;
#ifdef USE_SPECULARMAP
    vec4 texelSpecular = texture2D( specularMap, vUv );
    specularStrength = texelSpecular.r;
#else
    specularStrength = 1.0;
#endif
    ReflectedLight reflectedLight;
    reflectedLight.directDiffuse = vec3( 0.0 );
    reflectedLight.directSpecular = vec3( 0.0 );
    reflectedLight.indirectDiffuse = diffuseColor.rgb;
    reflectedLight.indirectSpecular = vec3( 0.0 );
    #ifdef USE_AOMAP
    float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
    reflectedLight.indirectDiffuse *= ambientOcclusion;
    #if defined( USE_ENVMAP ) && defined( PHYSICAL )
        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
    #endif
#endif

    vec3 outgoingLight = reflectedLight.indirectDiffuse;
    #ifdef DOUBLE_SIDED
    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
#else
    float flipNormal = 1.0;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vec3 reflectVec = reflect( cameraToVertex, worldNormal );
        #else
            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #else
        vec3 reflectVec = vReflect;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #elif defined( ENVMAP_TYPE_EQUIREC )
        vec2 sampleUV;
        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );
        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
        vec4 envColor = texture2D( envMap, sampleUV );
    #elif defined( ENVMAP_TYPE_SPHERE )
        vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
    #endif
    envColor = envMapTexelToLinear( envColor );
    #ifdef ENVMAP_BLENDING_MULTIPLY
        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_MIX )
        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_ADD )
        outgoingLight += envColor.xyz * specularStrength * reflectivity;
    #endif
#endif

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #ifdef PREMULTIPLIED_ALPHA
    gl_FragColor.rgb *= gl_FragColor.a;
#endif

    #if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif

      gl_FragColor = linearToOutputTexel( gl_FragColor );

    #ifdef USE_FOG
    #ifdef USE_LOGDEPTHBUF_EXT
        float depth = gl_FragDepthEXT / gl_FragCoord.w;
    #else
        float depth = gl_FragCoord.z / gl_FragCoord.w;
    #endif
    #ifdef FOG_EXP2
        float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif

}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define GAMMA_FACTOR 2
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

varying vec2 vUv;

float rand(vec2 co) {
  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
  gl_FragColor = vec4(vec3(rand(vUv)), 1.0);
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define USE_COLOR
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
    uniform vec4 offsetRepeat;
#endif

#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
#endif
#ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        varying vec3 vWorldPosition;
    #else
        varying vec3 vReflect;
        uniform float refractionRatio;
    #endif
#endif

#ifdef USE_COLOR
    varying vec3 vColor;
#endif
#ifdef USE_MORPHTARGETS
    #ifndef USE_MORPHNORMALS
    uniform float morphTargetInfluences[ 8 ];
    #else
    uniform float morphTargetInfluences[ 4 ];
    #endif
#endif
#ifdef USE_SKINNING
    uniform mat4 bindMatrix;
    uniform mat4 bindMatrixInverse;
    #ifdef BONE_TEXTURE
        uniform sampler2D boneTexture;
        uniform int boneTextureWidth;
        uniform int boneTextureHeight;
        mat4 getBoneMatrix( const in float i ) {
            float j = i * 4.0;
            float x = mod( j, float( boneTextureWidth ) );
            float y = floor( j / float( boneTextureWidth ) );
            float dx = 1.0 / float( boneTextureWidth );
            float dy = 1.0 / float( boneTextureHeight );
            y = dy * ( y + 0.5 );
            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
            mat4 bone = mat4( v1, v2, v3, v4 );
            return bone;
        }
    #else
        uniform mat4 boneMatrices[ MAX_BONES ];
        mat4 getBoneMatrix( const in float i ) {
            mat4 bone = boneMatrices[ int(i) ];
            return bone;
        }
    #endif
#endif

#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
    uniform float logDepthBufFC;
#endif
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    varying vec3 vViewPosition;
#endif

void main() {
    #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
#endif
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    vUv2 = uv2;
#endif
    #ifdef USE_COLOR
    vColor.xyz = color.xyz;
#endif
    #ifdef USE_SKINNING
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif
    #ifdef USE_ENVMAP
    
vec3 objectNormal = vec3( normal );

    #ifdef USE_MORPHNORMALS
    objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
    objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
    objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
    objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif

    #ifdef USE_SKINNING
    mat4 skinMatrix = mat4( 0.0 );
    skinMatrix += skinWeight.x * boneMatX;
    skinMatrix += skinWeight.y * boneMatY;
    skinMatrix += skinWeight.z * boneMatZ;
    skinMatrix += skinWeight.w * boneMatW;
    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif

    #ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif
vec3 transformedNormal = normalMatrix * objectNormal;

    #endif
    
vec3 transformed = vec3( position );

    #ifdef USE_MORPHTARGETS
    transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
    transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
    transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
    transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
    #ifndef USE_MORPHNORMALS
    transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
    transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
    transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
    transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
    #endif
#endif

    #ifdef USE_SKINNING
    vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned  = bindMatrixInverse * skinned;
#endif

    #ifdef USE_SKINNING
    vec4 mvPosition = modelViewMatrix * skinned;
#else
    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
#endif
gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_LOGDEPTHBUF
    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
    #else
        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
    #endif
#endif

    #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
    #ifdef USE_SKINNING
        vec4 worldPosition = modelMatrix * skinned;
    #else
        vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
    #endif
#endif

    #if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    vViewPosition = - mvPosition.xyz;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vWorldPosition = worldPosition.xyz;
    #else
        vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vReflect = reflect( cameraToVertex, worldNormal );
        #else
            vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #endif
#endif

}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define GAMMA_FACTOR 2
#define USE_COLOR
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
    varying vec3 vNormal;
#endif
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_COLOR
    varying vec3 vColor;
#endif

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
#endif
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
#endif
#ifdef USE_MAP
    uniform sampler2D map;
#endif

#ifdef USE_ALPHAMAP
    uniform sampler2D alphaMap;
#endif

#ifdef USE_AOMAP
    uniform sampler2D aoMap;
    uniform float aoMapIntensity;
#endif
#if defined( USE_ENVMAP ) || defined( PHYSICAL )
    uniform float reflectivity;
    uniform float envMapIntenstiy;
#endif
#ifdef USE_ENVMAP
    #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
        varying vec3 vWorldPosition;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        uniform samplerCube envMap;
    #else
        uniform sampler2D envMap;
    #endif
    uniform float flipEnvMap;
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
        uniform float refractionRatio;
    #else
        varying vec3 vReflect;
    #endif
#endif

#ifdef USE_FOG
    uniform vec3 fogColor;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif
#ifdef USE_SPECULARMAP
    uniform sampler2D specularMap;
#endif
#ifdef USE_LOGDEPTHBUF
    uniform float logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
#endif

#if NUM_CLIPPING_PLANES > 0
    #if ! defined( PHYSICAL ) && ! defined( PHONG )
        varying vec3 vViewPosition;
    #endif
    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif

void main() {
    #if NUM_CLIPPING_PLANES > 0
    for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {
        vec4 plane = clippingPlanes[ i ];
        if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
    }
#endif

    vec4 diffuseColor = vec4( diffuse, opacity );
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
    #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif

    #ifdef USE_COLOR
    diffuseColor.rgb *= vColor;
#endif
    #ifdef USE_ALPHAMAP
    diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif

    #ifdef ALPHATEST
    if ( diffuseColor.a < ALPHATEST ) discard;
#endif

    float specularStrength;
#ifdef USE_SPECULARMAP
    vec4 texelSpecular = texture2D( specularMap, vUv );
    specularStrength = texelSpecular.r;
#else
    specularStrength = 1.0;
#endif
    ReflectedLight reflectedLight;
    reflectedLight.directDiffuse = vec3( 0.0 );
    reflectedLight.directSpecular = vec3( 0.0 );
    reflectedLight.indirectDiffuse = diffuseColor.rgb;
    reflectedLight.indirectSpecular = vec3( 0.0 );
    #ifdef USE_AOMAP
    float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
    reflectedLight.indirectDiffuse *= ambientOcclusion;
    #if defined( USE_ENVMAP ) && defined( PHYSICAL )
        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
    #endif
#endif

    vec3 outgoingLight = reflectedLight.indirectDiffuse;
    #ifdef DOUBLE_SIDED
    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
#else
    float flipNormal = 1.0;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vec3 reflectVec = reflect( cameraToVertex, worldNormal );
        #else
            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #else
        vec3 reflectVec = vReflect;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #elif defined( ENVMAP_TYPE_EQUIREC )
        vec2 sampleUV;
        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );
        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
        vec4 envColor = texture2D( envMap, sampleUV );
    #elif defined( ENVMAP_TYPE_SPHERE )
        vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
    #endif
    envColor = envMapTexelToLinear( envColor );
    #ifdef ENVMAP_BLENDING_MULTIPLY
        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_MIX )
        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_ADD )
        outgoingLight += envColor.xyz * specularStrength * reflectivity;
    #endif
#endif

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #ifdef PREMULTIPLIED_ALPHA
    gl_FragColor.rgb *= gl_FragColor.a;
#endif

    #if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif

      gl_FragColor = linearToOutputTexel( gl_FragColor );

    #ifdef USE_FOG
    #ifdef USE_LOGDEPTHBUF_EXT
        float depth = gl_FragDepthEXT / gl_FragCoord.w;
    #else
        float depth = gl_FragCoord.z / gl_FragCoord.w;
    #endif
    #ifdef FOG_EXP2
        float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif

}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_NORMALMAP2 true
#define USE_AOMAP2 true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_NORMALMAP2 true
#define USE_AOMAP2 true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define USE_MAP
#define DOUBLE_SIDED
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
    uniform vec4 offsetRepeat;
#endif

#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
#endif
#ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        varying vec3 vWorldPosition;
    #else
        varying vec3 vReflect;
        uniform float refractionRatio;
    #endif
#endif

#ifdef USE_COLOR
    varying vec3 vColor;
#endif
#ifdef USE_MORPHTARGETS
    #ifndef USE_MORPHNORMALS
    uniform float morphTargetInfluences[ 8 ];
    #else
    uniform float morphTargetInfluences[ 4 ];
    #endif
#endif
#ifdef USE_SKINNING
    uniform mat4 bindMatrix;
    uniform mat4 bindMatrixInverse;
    #ifdef BONE_TEXTURE
        uniform sampler2D boneTexture;
        uniform int boneTextureWidth;
        uniform int boneTextureHeight;
        mat4 getBoneMatrix( const in float i ) {
            float j = i * 4.0;
            float x = mod( j, float( boneTextureWidth ) );
            float y = floor( j / float( boneTextureWidth ) );
            float dx = 1.0 / float( boneTextureWidth );
            float dy = 1.0 / float( boneTextureHeight );
            y = dy * ( y + 0.5 );
            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
            mat4 bone = mat4( v1, v2, v3, v4 );
            return bone;
        }
    #else
        uniform mat4 boneMatrices[ MAX_BONES ];
        mat4 getBoneMatrix( const in float i ) {
            mat4 bone = boneMatrices[ int(i) ];
            return bone;
        }
    #endif
#endif

#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
    uniform float logDepthBufFC;
#endif
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    varying vec3 vViewPosition;
#endif

void main() {
    #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
#endif
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    vUv2 = uv2;
#endif
    #ifdef USE_COLOR
    vColor.xyz = color.xyz;
#endif
    #ifdef USE_SKINNING
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif
    #ifdef USE_ENVMAP
    
vec3 objectNormal = vec3( normal );

    #ifdef USE_MORPHNORMALS
    objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
    objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
    objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
    objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif

    #ifdef USE_SKINNING
    mat4 skinMatrix = mat4( 0.0 );
    skinMatrix += skinWeight.x * boneMatX;
    skinMatrix += skinWeight.y * boneMatY;
    skinMatrix += skinWeight.z * boneMatZ;
    skinMatrix += skinWeight.w * boneMatW;
    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif

    #ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif
vec3 transformedNormal = normalMatrix * objectNormal;

    #endif
    
vec3 transformed = vec3( position );

    #ifdef USE_MORPHTARGETS
    transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
    transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
    transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
    transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
    #ifndef USE_MORPHNORMALS
    transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
    transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
    transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
    transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
    #endif
#endif

    #ifdef USE_SKINNING
    vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned  = bindMatrixInverse * skinned;
#endif

    #ifdef USE_SKINNING
    vec4 mvPosition = modelViewMatrix * skinned;
#else
    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
#endif
gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_LOGDEPTHBUF
    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
    #else
        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
    #endif
#endif

    #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
    #ifdef USE_SKINNING
        vec4 worldPosition = modelMatrix * skinned;
    #else
        vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
    #endif
#endif

    #if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    vViewPosition = - mvPosition.xyz;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vWorldPosition = worldPosition.xyz;
    #else
        vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vReflect = reflect( cameraToVertex, worldNormal );
        #else
            vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #endif
#endif

}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME MeshBasicMaterial
#define GAMMA_FACTOR 2
#define USE_MAP
#define DOUBLE_SIDED
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
    varying vec3 vNormal;
#endif
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_COLOR
    varying vec3 vColor;
#endif

#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
    varying vec2 vUv;
#endif
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
#endif
#ifdef USE_MAP
    uniform sampler2D map;
#endif

#ifdef USE_ALPHAMAP
    uniform sampler2D alphaMap;
#endif

#ifdef USE_AOMAP
    uniform sampler2D aoMap;
    uniform float aoMapIntensity;
#endif
#if defined( USE_ENVMAP ) || defined( PHYSICAL )
    uniform float reflectivity;
    uniform float envMapIntenstiy;
#endif
#ifdef USE_ENVMAP
    #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
        varying vec3 vWorldPosition;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        uniform samplerCube envMap;
    #else
        uniform sampler2D envMap;
    #endif
    uniform float flipEnvMap;
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
        uniform float refractionRatio;
    #else
        varying vec3 vReflect;
    #endif
#endif

#ifdef USE_FOG
    uniform vec3 fogColor;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif
#ifdef USE_SPECULARMAP
    uniform sampler2D specularMap;
#endif
#ifdef USE_LOGDEPTHBUF
    uniform float logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
#endif

#if NUM_CLIPPING_PLANES > 0
    #if ! defined( PHYSICAL ) && ! defined( PHONG )
        varying vec3 vViewPosition;
    #endif
    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif

void main() {
    #if NUM_CLIPPING_PLANES > 0
    for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {
        vec4 plane = clippingPlanes[ i ];
        if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
    }
#endif

    vec4 diffuseColor = vec4( diffuse, opacity );
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
    #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif

    #ifdef USE_COLOR
    diffuseColor.rgb *= vColor;
#endif
    #ifdef USE_ALPHAMAP
    diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif

    #ifdef ALPHATEST
    if ( diffuseColor.a < ALPHATEST ) discard;
#endif

    float specularStrength;
#ifdef USE_SPECULARMAP
    vec4 texelSpecular = texture2D( specularMap, vUv );
    specularStrength = texelSpecular.r;
#else
    specularStrength = 1.0;
#endif
    ReflectedLight reflectedLight;
    reflectedLight.directDiffuse = vec3( 0.0 );
    reflectedLight.directSpecular = vec3( 0.0 );
    reflectedLight.indirectDiffuse = diffuseColor.rgb;
    reflectedLight.indirectSpecular = vec3( 0.0 );
    #ifdef USE_AOMAP
    float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
    reflectedLight.indirectDiffuse *= ambientOcclusion;
    #if defined( USE_ENVMAP ) && defined( PHYSICAL )
        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
    #endif
#endif

    vec3 outgoingLight = reflectedLight.indirectDiffuse;
    #ifdef DOUBLE_SIDED
    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
#else
    float flipNormal = 1.0;
#endif

    #ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vec3 reflectVec = reflect( cameraToVertex, worldNormal );
        #else
            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #else
        vec3 reflectVec = vReflect;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #elif defined( ENVMAP_TYPE_EQUIREC )
        vec2 sampleUV;
        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );
        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
        vec4 envColor = texture2D( envMap, sampleUV );
    #elif defined( ENVMAP_TYPE_SPHERE )
        vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
    #endif
    envColor = envMapTexelToLinear( envColor );
    #ifdef ENVMAP_BLENDING_MULTIPLY
        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_MIX )
        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_ADD )
        outgoingLight += envColor.xyz * specularStrength * reflectivity;
    #endif
#endif

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #ifdef PREMULTIPLIED_ALPHA
    gl_FragColor.rgb *= gl_FragColor.a;
#endif

    #if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif

      gl_FragColor = linearToOutputTexel( gl_FragColor );

    #ifdef USE_FOG
    #ifdef USE_LOGDEPTHBUF_EXT
        float depth = gl_FragDepthEXT / gl_FragCoord.w;
    #else
        float depth = gl_FragCoord.z / gl_FragCoord.w;
    #endif
    #ifdef FOG_EXP2
        float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif

}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_LIGHTMAP true
#define ALPHATEST true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_LIGHTMAP true
#define ALPHATEST true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_AOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_AOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define DOUBLE_SIDED
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

uniform mat4 textureMatrix;
varying vec4 mirrorCoord;
varying vec3 worldPosition;
void main() {
vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
vec4 worldPos = modelMatrix * vec4( position, 1.0 );
mirrorCoord = textureMatrix * worldPos;
worldPosition = worldPos.xyz;
gl_Position = projectionMatrix * mvPosition;
}
__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define GAMMA_FACTOR 2
#define DOUBLE_SIDED
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

precision highp float;
uniform sampler2D mirrorSampler;
uniform float alpha;
uniform float time;
uniform float distortionScale;
uniform sampler2D normalSampler;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform vec3 eye;
uniform vec3 color;
varying vec4 mirrorCoord;
varying vec3 worldPosition;
vec4 getNoise( vec2 uv )
{
float uvScale = 0.5;
float t = time * uvScale;
    vec2 uv0 = ( uv / 20.0 ) + vec2(t / 17.0, t / 29.0);
    vec2 uv1 = (uv / 30.0) - vec2( t / -19.0, t / 31.0 );
    vec2 uv2 = uv / vec2( 9.0, 18.0 ) + vec2( t / 101.0, t / 97.0 );
    vec2 uv3 = uv / vec2( 13.0, 20.0 ) - vec2( t / 109.0, t / -113.0 );
uv0 /= uvScale;
uv1 /= uvScale;
uv2 /= uvScale;
uv3 /= uvScale;
    vec4 noise = texture2D( normalSampler, uv0 ) + texture2D( normalSampler, uv1 ) + texture2D(normalSampler, uv2) + texture2D(normalSampler, uv3);
    return noise * 0.5 - 1.0;
}
void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor )
{
    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
    float direction = max( 0.0, dot( eyeDirection, reflection ) );
    specularColor += pow( direction, shiny ) * sunColor * spec;
    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
}
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_FOG
    uniform vec3 fogColor;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif
float blendOverlay(float base, float blend) {
return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
}
void main()
{
    vec4 noise = getNoise( worldPosition.xz );
    vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );
    vec3 diffuseLight = vec3(0.0);
    vec3 specularLight = vec3(0.0);
    vec3 worldToEye = eye - worldPosition;
    vec3 eyeDirection = normalize( worldToEye );
    sunLight( surfaceNormal, eyeDirection, 200.0, 1.5, 0.5, diffuseLight, specularLight );
    float distance = length(worldToEye);
    vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
 vec4 mirrorDistord = mirrorCoord;
 mirrorDistord.x += distortion.x;
 mirrorDistord.w += distortion.y;
    vec3 reflectionSample = texture2DProj( mirrorSampler, mirrorDistord ).rgb;
reflectionSample = vec3(0.565, 0.714, 0.831);
    float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
    float rf0 = 0.3;
 float d = 1.0 - clamp(distance / 1500.0, 0.0, 1.0);
    float reflectance = d * clamp(rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 ), 0.0, 1.0);
 reflectance = 1.0;
    vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * color;
    vec3 albedo = mix( sunColor * diffuseLight * 0.3 + scatter, ( mix(scatter, reflectionSample, 0.75) + reflectionSample * specularLight ), reflectance );
    vec3 outgoingLight = albedo;
#ifdef USE_FOG
    #ifdef USE_LOGDEPTHBUF_EXT
        float depth = gl_FragDepthEXT / gl_FragCoord.w;
    #else
        float depth = gl_FragCoord.z / gl_FragCoord.w;
    #endif
    #ifdef FOG_EXP2
        float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif

    gl_FragColor = vec4( outgoingLight, max(alpha, specularLight.r) );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_LIGHTMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_LIGHTMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_NORMALMAP true
#define USE_NORMALMAP2 true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_NORMALMAP true
#define USE_NORMALMAP2 true
#define USE_METALGLOSSMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP2 true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP2 true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

uniform float objectScale;

void main() {
  float thickness = 0.015 / objectScale;
  vec4 worldPos = modelMatrix * vec4(position, 1.0);
  vec4 worldNormal = modelMatrix * vec4(normal, 0.0);
 
  worldPos += worldNormal * thickness;
  gl_Position = projectionMatrix * viewMatrix * worldPos;
}
__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define GAMMA_FACTOR 2
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

uniform vec3 diffuse;
uniform float opacity;

void main() {
  gl_FragColor = vec4(diffuse, opacity);
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define USE_MAP
#define NUM_CLIPPING_PLANES 0
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME ShaderMaterial
#define GAMMA_FACTOR 2
#define USE_MAP
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform sampler2D noiseMap;

uniform vec3 diffuse;
uniform float opacity;
uniform float threshold;
uniform float range;

const vec3 white = vec3(1.0);

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 mapTexel = texture2D(map, vUv);
  #endif

  vec3 noise = texture2D(noiseMap, vUv).rgb;

  float v = fract(noise.r + threshold * 0.75);
  v = step(0.9, v);

  float alpha = step(0.5, (v * mapTexel.a));

  gl_FragColor = vec4(white, alpha);
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_AOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_AOMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_PACKEDMAP true
#define USE_EMISSIVEMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_PACKEDMAP true
#define USE_EMISSIVEMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP2 true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_NORMALMAP true
#define USE_AOMAP2 true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_AOMAP2 true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_AOMAP2 true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME PointsMaterial
#define VERTEX_TEXTURES
#define GAMMA_FACTOR 2
#define MAX_BONES 1019
#define USE_MAP
#define NUM_CLIPPING_PLANES 0
#define USE_SIZEATTENUATION
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif

uniform float size;
uniform float scale;
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_COLOR
    varying vec3 vColor;
#endif
#ifdef USE_SHADOWMAP
    #if 0 > 0
        uniform mat4 directionalShadowMatrix[ 0 ];
        varying vec4 vDirectionalShadowCoord[ 0 ];
    #endif
    #if 0 > 0
        uniform mat4 spotShadowMatrix[ 0 ];
        varying vec4 vSpotShadowCoord[ 0 ];
    #endif
    #if 0 > 0
        uniform mat4 pointShadowMatrix[ 0 ];
        varying vec4 vPointShadowCoord[ 0 ];
    #endif
#endif

#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
    uniform float logDepthBufFC;
#endif
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    varying vec3 vViewPosition;
#endif

void main() {
    #ifdef USE_COLOR
    vColor.xyz = color.xyz;
#endif
    
vec3 transformed = vec3( position );

    #ifdef USE_SKINNING
    vec4 mvPosition = modelViewMatrix * skinned;
#else
    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
#endif
gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_SIZEATTENUATION
        gl_PointSize = size * ( scale / - mvPosition.z );
    #else
        gl_PointSize = size;
    #endif
    #ifdef USE_LOGDEPTHBUF
    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
    #else
        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
    #endif
#endif

    #if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
    vViewPosition = - mvPosition.xyz;
#endif

    #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
    #ifdef USE_SKINNING
        vec4 worldPosition = modelMatrix * skinned;
    #else
        vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
    #endif
#endif

    #ifdef USE_SHADOWMAP
    #if 0 > 0
    
    #endif
    #if 0 > 0
    
    #endif
    #if 0 > 0
    
    #endif
#endif

}

__FRAGMENTSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME PointsMaterial
#define GAMMA_FACTOR 2
#define USE_MAP
#define NUM_CLIPPING_PLANES 0
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#define TONE_MAPPING
#define saturate(a) clamp( a, 0.0, 1.0 )
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
  return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
  color *= toneMappingExposure;
  color = max( vec3( 0.0 ), color - 0.004 );
  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}

vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }

vec4 LinearToLinear( in vec4 value ) {
  return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
  float maxComponent = max( max( value.r, value.g ), value.b );
  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
  return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
  float maxRGB = max( value.x, max( value.g, value.b ) );
  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
  M            = ceil( M * 255.0 ) / 255.0;
  return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
    float maxRGB = max( value.x, max( value.g, value.b ) );
    float D      = max( maxRange / maxRGB, 1.0 );
    D            = min( floor( D ) / 255.0, 1.0 );
    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
  vec4 vResult;
  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
  vResult.w = fract(Le);
  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
  return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
  float Le = value.z * 255.0 + value.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
  return vec4( max(vRGB, 0.0), 1.0 );
}

vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }

uniform vec3 diffuse;
uniform float opacity;
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract(sin(sn) * c);
}
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    float distance = dot( planeNormal, point - pointOnPlane );
    return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}

#ifdef USE_COLOR
    varying vec3 vColor;
#endif

#ifdef USE_MAP
    uniform vec4 offsetRepeat;
    uniform sampler2D map;
#endif

#ifdef USE_FOG
    uniform vec3 fogColor;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif
#ifdef USE_SHADOWMAP
    #if 0 > 0
        uniform sampler2D directionalShadowMap[ 0 ];
        varying vec4 vDirectionalShadowCoord[ 0 ];
    #endif
    #if 0 > 0
        uniform sampler2D spotShadowMap[ 0 ];
        varying vec4 vSpotShadowCoord[ 0 ];
    #endif
    #if 0 > 0
        uniform sampler2D pointShadowMap[ 0 ];
        varying vec4 vPointShadowCoord[ 0 ];
    #endif
    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
    }
    float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
        const vec2 offset = vec2( 0.0, 1.0 );
        vec2 texelSize = vec2( 1.0 ) / size;
        vec2 centroidUV = floor( uv * size + 0.5 ) / size;
        float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
        float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
        float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
        float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
        vec2 f = fract( uv * size + 0.5 );
        float a = mix( lb, lt, f.y );
        float b = mix( rb, rt, f.y );
        float c = mix( a, b, f.x );
        return c;
    }
    float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;
        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );
        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
        bool frustumTest = all( frustumTestVec );
        if ( frustumTest ) {
        #if defined( SHADOWMAP_TYPE_PCF )
            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx0 = - texelSize.x * shadowRadius;
            float dy0 = - texelSize.y * shadowRadius;
            float dx1 = + texelSize.x * shadowRadius;
            float dy1 = + texelSize.y * shadowRadius;
            return (
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
            ) * ( 1.0 / 9.0 );
        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx0 = - texelSize.x * shadowRadius;
            float dy0 = - texelSize.y * shadowRadius;
            float dx1 = + texelSize.x * shadowRadius;
            float dy1 = + texelSize.y * shadowRadius;
            return (
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
            ) * ( 1.0 / 9.0 );
        #else
            return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
        #endif
        }
        return 1.0;
    }
    vec2 cubeToUV( vec3 v, float texelSizeY ) {
        vec3 absV = abs( v );
        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
        vec2 planar = v.xy;
        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;
        if ( absV.z >= almostOne ) {
            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;
        } else if ( absV.x >= almostOne ) {
            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;
        } else if ( absV.y >= almostOne ) {
            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;
        }
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
    }
    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
        vec3 lightToPosition = shadowCoord.xyz;
        vec3 bd3D = normalize( lightToPosition );
        float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;
        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
            vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
            return (
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
            ) * ( 1.0 / 9.0 );
        #else
            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
        #endif
    }
#endif

#ifdef USE_LOGDEPTHBUF
    uniform float logDepthBufFC;
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
    #endif
#endif

#if NUM_CLIPPING_PLANES > 0
    #if ! defined( PHYSICAL ) && ! defined( PHONG )
        varying vec3 vViewPosition;
    #endif
    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif

void main() {
    #if NUM_CLIPPING_PLANES > 0
    for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {
        vec4 plane = clippingPlanes[ i ];
        if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
    }
#endif

    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vec4( diffuse, opacity );
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
    #ifdef USE_MAP
    vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );
    diffuseColor *= mapTexelToLinear( mapTexel );
#endif

    #ifdef USE_COLOR
    diffuseColor.rgb *= vColor;
#endif
    #ifdef ALPHATEST
    if ( diffuseColor.a < ALPHATEST ) discard;
#endif

    outgoingLight = diffuseColor.rgb;
    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #ifdef PREMULTIPLIED_ALPHA
    gl_FragColor.rgb *= gl_FragColor.a;
#endif

    #if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif

      gl_FragColor = linearToOutputTexel( gl_FragColor );

    #ifdef USE_FOG
    #ifdef USE_LOGDEPTHBUF_EXT
        float depth = gl_FragDepthEXT / gl_FragCoord.w;
    #else
        float depth = gl_FragCoord.z / gl_FragCoord.w;
    #endif
    #ifdef FOG_EXP2
        float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif

}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

attribute vec3 position;
attribute vec3 normal;
attribute vec4 tangent;
attribute vec2 uv;
attribute vec2 uv2;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform vec4 offsetRepeat;
uniform vec4 offsetRepeatDetail;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  FragEyeVector = viewMatrix * worldPosition;

  

  gl_Position = projectionMatrix * FragEyeVector;

  vUv = uv.xy * offsetRepeat.zw + offsetRepeat.xy;

  #if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
  vUvDetail = uv.xy * offsetRepeatDetail.zw + offsetRepeatDetail.xy;
  #endif

  FragNormal = normalMatrix * normal;
  FragTangent.xyz = normalMatrix * tangent.xyz;
  FragTangent.w = tangent.w;

  #ifdef USE_LIGHTMAP
  vUv2 = uv2.xy;
  #endif
}

__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
precision highp float;
precision highp int;
#define SHADER_NAME RawShaderMaterial
#define USE_ALBEDOMAP true
#define USE_PACKEDMAP true
#define USE_LIGHTMAP true
#define CUBEMAP true
#define OCCLUDE_SPECULAR true
#define USE_DIR_LIGHT true

#define MOBILE
#define LUV

uniform float uAOPBRFactor;
uniform float uAlbedoPBRFactor;
uniform float uEnvironmentExposure;
uniform float uGlossinessPBRFactor;
uniform float uMetalnessPBRFactor;
uniform float uNormalMapFactor;
uniform float uOpacityFactor;
uniform float uSpecularF0Factor;

uniform int uMode;
uniform vec3 uColor;
uniform float uAlphaTest;

uniform int uFlipY;
uniform int uOccludeSpecular;
uniform int uOutputLinear;

uniform samplerCube sSpecularPBR;
uniform sampler2D sPanoramaPBR;

uniform sampler2D sTextureAlbedoMap;
uniform sampler2D sTextureAlbedoMap2;
uniform sampler2D sTextureNormalMap;
uniform sampler2D sTextureNormalMap2;
#ifdef USE_PACKEDMAP
uniform sampler2D sTexturePackedMap;
#else
uniform sampler2D sTextureAOMap;
uniform sampler2D sTextureMetalGlossMap;
#endif
uniform sampler2D sTextureAOMap2;
uniform sampler2D sTextureEmissiveMap;

uniform vec2 uTextureEnvironmentSpecularPBRLodRange;
uniform vec2 uTextureEnvironmentSpecularPBRTextureSize;
uniform vec3 uDiffuseSPH[9];
uniform mat4 uEnvironmentTransform;


varying vec3 FragNormal;
varying vec4 FragTangent;
varying vec4 FragEyeVector;
varying vec2 vUv;

#if defined(USE_ALBEDO2) || defined(USE_NORMALMAP2) || defined(USE_AOMAP2)
varying vec2 vUvDetail;
#endif

#ifdef USE_LIGHTMAP
  uniform sampler2D sTextureLightMap;
  uniform sampler2D sTextureLightMapM;
  varying vec2 vUv2;
#endif

#ifdef USE_DIR_LIGHT
uniform vec3 viewLightDir;
uniform vec3 lightColor;
uniform int highlights;
#endif

vec3 DecodeLightmapRGBM(vec4 data, vec2 decodeInstructions) {
  return (decodeInstructions.x * pow(abs(data.a), decodeInstructions.y)) * data.rgb;
}






float linearTosRGB(const in float c) {
  if (c >= 1.0) return 1.0;
  float S1 = sqrt(c);
  float S2 = sqrt(S1);
  float S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
}

vec3 linearTosRGB(const in vec3 c) {
  
  vec3 cm = c;
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;
}

vec4 linearTosRGB(const in vec4 c) {
  vec3 cm = min(c.rgb, 1.0);
  vec3 S1 = sqrt(cm);
  vec3 S2 = sqrt(S1);
  vec3 S3 = sqrt(S2);
  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);
}

float sRGBToLinear(const in float c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec3 sRGBToLinear(const in vec3 c) {
  return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
}

vec4 sRGBToLinear(const in vec4 c) {
  return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);
}


vec3 RGBMToRGB(const in vec4 rgba) {
  const float maxRange = 8.0;
  return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3(6.0013,    -2.700,   -1.7995,
                -1.332,    3.1029,   -5.7720,
                0.3007,    -1.088,    5.6268);

vec3 LUVToRGB(const in vec4 vLogLuv) {
  float Le = vLogLuv.z * 255.0 + vLogLuv.w;
  vec3 Xp_Y_XYZp;
  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
  vec3 vRGB = LUVInverse * Xp_Y_XYZp;
  return max(vRGB, 0.0);
}


vec4 encodeRGBM(const in vec3 col, const in float range) {
  if(range <= 0.0)
    return vec4(col, 1.0);
  vec4 rgbm;
  vec3 color = col / range;
  rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);
  rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
  rgbm.rgb = color / rgbm.a;
  return rgbm;
}

vec3 decodeRGBM(const in vec4 col, const in float range) {
  if(range <= 0.0)
    return col.rgb;
  return range * col.rgb * col.a;
}

vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgb;
}

vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).rgba;
}

float textureIntensity(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv).r;
}

float textureAlpha(const in sampler2D texture, const in vec2 uv) {
  return texture2D(texture, uv.xy).a;
}

float adjustSpecular(const in float specular, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return 1.0-min(1.0, sqrt((1.0-specular) * (1.0-specular) + 1.0/kappa));
  }
  return specular;
}

vec3 mtexNspaceTangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal) {
  vec3 tang = vec3(0.0,1.0,0.0);
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    tang =  tangent.xyz / l;
  }
  vec3 B = tangent.w * normalize(cross(normal, tang));
  return normalize(texnormal.x*tang + texnormal.y*B + texnormal.z*normal);
}

vec2 normalMatcap(const in vec3 normal, const in vec3 nm_z) {
  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);
  vec3 nm_y = cross(nm_x, nm_z);
  return vec2(dot(normal.xz, nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5) ; 
}

vec3 rgbToNormal(const in vec3 texel, const in int flipNormalY) {
  vec3 rgb = texel * vec3(2.0) + vec3(-1.0); 
  rgb[1] = flipNormalY == 1 ? -rgb[1] : rgb[1];
  return rgb;
}

vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
  vec3 outnormal;
  float l = length(tangent.xyz);
  if (l != 0.0) {
    
    
    vec3 tang =  tangent.xyz / l;
    vec3 binormal = tangent.w * normalize(cross(normal, tang));
    outnormal = normal + gradient.x * tang + gradient.y * binormal;
  }
  else {
     outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
  }
  return normalize(outnormal);
}

float specularOcclusion(const in int occlude, const in float ao, const in vec3 N, const in vec3 V) {
  if(occlude == 0)
    return 1.0;
  
  
  float d = dot(N, V) + ao;
  return clamp((d * d) - 1.0 + ao, 0.0, 1.0);
}

float adjustRoughnessNormalMap(const in float roughness, const in vec3 normal) {
  
  float normalLen = length(normal);
  if (normalLen < 1.0) {
    float normalLen2 = normalLen * normalLen;
    float kappa = (3.0 * normalLen -  normalLen2 * normalLen)/(1.0 - normalLen2);
    
    
    return min(1.0, sqrt(roughness * roughness + 1.0/kappa));
  }
  return roughness;
}

float adjustRoughnessGeometry(const in float roughness, const in vec3 normal) {
  
  





  return roughness;

}

mat3 environmentTransformPBR(const in mat4 tr) {
  
  vec3 x = vec3(tr[0][0], tr[1][0], tr[2][0]);
  vec3 y = vec3(tr[0][1], tr[1][1], tr[2][1]);
  vec3 z = vec3(tr[0][2], tr[1][2], tr[2][2]);
  mat3 m = mat3(x, y, z);
  return m;
}

vec3 evaluateDiffuseSphericalHarmonics(const in vec3 s[9], const in mat3 envTrans, const in vec3 N) {
  vec3 n = envTrans * N;
  
  vec3 result = (s[0]+s[1]*n.y+s[2]*n.z+s[3]*n.x+s[4]*n.y*n.x+s[5]*n.y*n.z+s[6]*(3.0*n.z*n.z-1.0)+s[7]*(n.z*n.x)+s[8]*(n.x*n.x-n.y*n.y));
  return max(result, vec3(0.0));
}



float linRoughnessToMipmap(const in float roughnessLinear) {
  return sqrt(roughnessLinear);
}

vec3 integrateBRDF(const in vec3 specular, const in float r, const in float NoV, const in sampler2D tex) {
  vec4 rgba = texture2D(tex, vec2(NoV, r));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);
  const float div = 1.0/65535.0;
  return (specular * a + b) * div;
}



vec3 integrateBRDFApprox(const in vec3 specular, const in float roughness, const in float NoV) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
  vec4 r = roughness * c0 + c1;
  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
  return specular * AB.x + AB.y;
}

vec3 computeIBLDiffuseUE4(const in vec3 normal, const in vec3 albedo, const in mat3 envTrans, const in vec3 sphHarm[9]) {
  
  
  return evaluateDiffuseSphericalHarmonics(sphHarm, envTrans, normal);
}


#ifdef CUBEMAP
vec3 textureCubemapLod(const in samplerCube texture, const in vec3 dir, const in float lod) {
  vec4 rgba = textureCubeLodEXT(texture, dir, lod);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 textureCubeLodEXTFixed(const in samplerCube texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLod) {
  vec3 dir = direction;
  float lod = min(maxLod, lodInput);

  
  float scale = 1.0 - exp2(lod) / size.x;
  vec3 absDir = abs(dir);
  float M = max(max(absDir.x, absDir.y), absDir.z);

  if (absDir.x != M) dir.x *= scale;
  if (absDir.y != M) dir.y *= scale;
  if (absDir.z != M) dir.z *= scale;

  return textureCubemapLod(texture, dir, lod);
}

vec3 prefilterEnvMapCube(const in float rLinear, const in vec3 R, const in samplerCube tex, const in vec2 lodRange, const in vec2 size){
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1];
  return textureCubeLodEXTFixed(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv samplerCube
#define prefilterEnvMap prefilterEnvMapCube

#else
#ifdef PANORAMA
vec2 computeUVForMipmap(const in float level, const in vec2 uvBase, const in float size, const in float maxLOD) {
  vec2 uv = uvBase;
  float widthForLevel = exp2(maxLOD - level);
  float heightForLevel = widthForLevel * 0.5;
  float widthFactor = pow(0.5, level);
  float heightFactor = widthFactor * 0.5;
  float texelSize = 1.0 / size;

  uv.y = 1.0 - uv.y;

  float resizeX = (widthForLevel - 2.0) * texelSize;
  float resizeY = (heightForLevel - 2.0) * texelSize;

  float uvSpaceLocalX = texelSize + uv.x * resizeX;
  float uvSpaceLocalY = texelSize + uv.y * resizeY;

  uvSpaceLocalY += heightFactor;

  return vec2(uvSpaceLocalX, uvSpaceLocalY);
}

vec2 normalToPanoramaUVY(const in vec3 dir) {
  float n = length(dir.xz);

  
  vec2 pos = vec2((n > 0.0000001) ? max(-1.0, dir.x / n) : 0.0, dir.y);

  
  if (pos.x > 0.0) pos.x = min(0.999999, pos.x);

  pos = acos(pos) * 0.3183098861837907; 

  pos.x = (dir.z > 0.0) ? pos.x * 0.5 : 1.0 - (pos.x * 0.5);

  
  pos.x = mod(pos.x - 0.25 + 1.0, 1.0);
  pos.y = 1.0 - pos.y;
  return pos;
}

vec3 texturePanorama(const in sampler2D texture, const in vec2 uv) {
  vec4 rgba = texture2D(texture, uv);
#ifdef FLOAT
  return rgba.rgb;
#endif
#ifdef RGBM
  return RGBMToRGB(rgba);
#endif
#ifdef LUV
  return LUVToRGB(rgba);
#endif
}

vec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size, const in vec3 direction, const in float lodInput, const in float maxLOD) {
  float lod = min(maxLOD, lodInput);
  vec2 uvBase = normalToPanoramaUVY(direction);

  float lod0 = floor(lod);
  vec2 uv0 = computeUVForMipmap(lod0, uvBase, size.x, maxLOD);
  vec3 texel0 = texturePanorama(texture, uv0.xy);

  float lod1 = ceil(lod);
  vec2 uv1 = computeUVForMipmap(lod1, uvBase, size.x, maxLOD);
  vec3 texel1 = texturePanorama(texture, uv1.xy);

  return mix(texel0, texel1, fract(lod));
}

vec3 prefilterEnvMapPanorama(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  float lod = linRoughnessToMipmap(rLinear) * lodRange[1]; 
  return texturePanoramaLod(tex, size, R, lod, lodRange[0]);
}

#define samplerEnv sampler2D
#define prefilterEnvMap prefilterEnvMapPanorama

#else

vec3 prefilterEnvMap(const in float rLinear, const in vec3 R, const in sampler2D tex, const in vec2 lodRange, const in vec2 size) {
  return vec3(0.0);
}
#define samplerEnv sampler2D
#endif // PANORAMA

#endif // CUBEMAP

vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness) {
  float smoothness = 1.0 - realRoughness;
  float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);
  
  return mix(N, R, lerpFactor);
}


vec3 computeIBLSpecularUE4(
  const in vec3 N,
  const in vec3 V,
  const in float rLinear,
  const in vec3 specular,
  const in mat3 envTrans,
  const in samplerEnv texEnv,
  const in vec2 lodRange,
  const in vec2 size,
  const in vec3 frontNormal
  #ifdef MOBILE
){
  #else
  ,const in sampler2D texBRDF) {
  #endif

  float rough = max(rLinear, 0.0);

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = normalize(NoV * 2.0 * N - V);

  R = getSpecularDominantDir(N, R, rLinear);
  
  

  vec3 dir = envTrans * R;
  dir.xz *= -1.0;

  vec3 prefilteredColor = prefilterEnvMap(rough, dir, texEnv, lodRange, size);
  
  
  float factor = clamp(1.0 + 1.3 * dot(R, frontNormal), 0.1, 1.0);
  prefilteredColor *= factor * factor;
  #ifdef MOBILE
  return prefilteredColor * integrateBRDFApprox(specular, rough, NoV);
  #else
  return prefilteredColor * integrateBRDF(specular, rough, NoV, texBRDF);
  #endif
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}


#ifdef USE_DIR_LIGHT

#define PI 3.141593
#define G1V(dotNV, k) (1.0 / (dotNV * (1.0 - k) + k))
#define saturate(_x) clamp(_x, 0.0, 1.0)

vec4 LightingFuncPrep(const in vec3 N,
                      const in vec3 V,
                      const in float roughness)
{

    float dotNV = saturate(dot(N,V));
    float alpha = roughness * roughness;
    float k = alpha * .5;
    float visNV = G1V(dotNV,k);

    vec4 prepSpec;

    prepSpec.x = alpha;
    prepSpec.y = alpha * alpha;
    prepSpec.z = k;
    prepSpec.w = visNV;

    return prepSpec;

}

vec3 LightingFuncUsePrepGGX(const vec4 prepSpec,
              const vec3 N,
              const vec3 V,
              const vec3 L,
              const vec3 F0,
              const float dotNL)
{
  vec3 H = normalize(V + L);
  float dotNH = saturate(dot(N, H));
  
  float alphaSqr = prepSpec.y;
  float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;
  float D = alphaSqr / (PI * denom * denom);
  
  float dotLH = saturate(dot(L, H));
  float dotLH5 = pow(1.0 - dotLH, 5.0);
  vec3 F = vec3(F0) + (vec3(1.0) - F0) * (dotLH5);
  
  float visNL = G1V(dotNL, prepSpec.z);
  vec3 specular = D * F * visNL * prepSpec.w;

  return specular;
}


vec3 computeLight(const in vec3 lightColor,
          const in vec3 albedoColor,
          const in vec3 normal,
          const in vec3 viewDir,
          const in vec3 lightDir,
          const in vec3 specular,
          const in vec4 prepSpec,
          const in float dotNL)
{
  vec3 cSpec = LightingFuncUsePrepGGX(prepSpec, normal, viewDir, lightDir, specular, dotNL);
  return lightColor * dotNL * cSpec;
}

vec3 computeSunLightPBRShading(
  const in vec3 normal,
  const in vec3 eyeVector,

  const in vec3 albedo,
  const in vec4 prepSpec,
  const in vec3 specular,

  const in vec3 lightColor,
  const in vec3 lightEyeDir)
{
  bool lighted = false;
  float NdotL = dot(lightEyeDir, normal);
  if (NdotL > 0.0)
  {
    lighted = true;
    return computeLight(lightColor, albedo, normal, eyeVector, lightEyeDir, specular, prepSpec,  NdotL);
  }
  return vec3(0.0);
}
#endif


void main() {
  vec3 eyeVector = normalize(-FragEyeVector.rgb);
  mat3 transform = environmentTransformPBR(uEnvironmentTransform);

  vec4 frontTangent = gl_FrontFacing ? FragTangent : -FragTangent;
  vec3 frontNormal = gl_FrontFacing ? FragNormal : -FragNormal;

  vec3 normal = normalize(frontNormal);

  
  #ifdef USE_NORMALMAP
    vec3 nmTexel = rgbToNormal(textureRGB(sTextureNormalMap, vUv.xy), uFlipY);
    vec3 normalMap = vec3(uNormalMapFactor * nmTexel.xy, nmTexel.z);
    vec3 geoNormal = mtexNspaceTangent(frontTangent, normal, normalMap);

  #else
    vec3 geoNormal = normal;
  #endif

  
  #ifdef USE_NORMALMAP2
    vec3 nm2Texel = rgbToNormal(textureRGB(sTextureNormalMap2, vUvDetail.xy), uFlipY);
    vec3 normalMap2 = vec3(uNormalMapFactor * nm2Texel.xy, nm2Texel.z);
    vec3 geoNormal2 = mtexNspaceTangent(frontTangent, normal, normalMap2);

    geoNormal = mix(geoNormal, geoNormal2, 0.5);
  #endif

  
  #if defined(USE_PACKEDMAP)
  vec3 combinedTexel = textureRGB(sTexturePackedMap, vUv.xy);
  #elif defined(USE_METALGLOSSMAP)
  vec3 combinedTexel = textureRGB(sTextureMetalGlossMap, vUv.xy);
  #else
  vec3 combinedTexel = vec3(1.0, 1.0, 1.0);
  #endif
  float metalness = combinedTexel.r;
  float glossiness = combinedTexel.b;
  float channelMetalnessPBR = metalness * uMetalnessPBRFactor;
  float channelGlossinessPBR = glossiness * uGlossinessPBRFactor;
  float roughness = 1.0 - channelGlossinessPBR;
  float tmp_51 = max(1.e-4, roughness);
  #ifdef USE_NORMALMAP
    float tmp_52 = adjustRoughnessNormalMap(tmp_51, normalMap);
    float materialRoughness = adjustRoughnessGeometry(tmp_52, normal);
  #else
    float materialRoughness = tmp_51;
  #endif

  
  vec4 albedoMap = vec4(uColor, 1.0);
  #ifdef USE_ALBEDOMAP
    albedoMap *= textureRGBA(sTextureAlbedoMap, vUv.xy);
  #endif

  
  #ifdef USE_ALBEDOMAP2
    albedoMap *= textureRGBA(sTextureAlbedoMap2, vUvDetail.xy);
  #endif

  vec3 channelAlbedoPBR = sRGBToLinear(albedoMap.rgb) * uAlbedoPBRFactor;
  vec3 materialDiffusePBR = channelAlbedoPBR * (1.0 - channelMetalnessPBR);

  
  #if defined(USE_PACKEDMAP)
  float ao = combinedTexel.g;
  #elif defined(USE_AOMAP)
  float ao = textureIntensity(sTextureAOMap, vUv.xy);
  #else
  float ao = 1.0;
  #endif

  #ifdef USE_AOMAP2
    ao *= textureIntensity(sTextureAOMap2, vUvDetail.xy);
  #endif
  float channelAOPBR = mix(1.0, ao, uAOPBRFactor);

  
  float luminance = 1.0;
  #ifdef USE_LIGHTMAP
    #ifdef USE_NORMALMAP
      luminance = luma(computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH));
      luminance = mix(luminance, 1.0, abs(dot(geoNormal, normal)));
      if (uMode == -1) {
        luminance = 1.0;
      }

      vec3 diffuse = materialDiffusePBR * luminance;
    #else
      vec3 diffuse = materialDiffusePBR;
    #endif
  #else
  vec3 diffuse = materialDiffusePBR * computeIBLDiffuseUE4(geoNormal, materialDiffusePBR, transform, uDiffuseSPH);
  #endif

  diffuse *= channelAOPBR;

  #ifdef USE_LIGHTMAP
    vec3 lightmapTexel = textureRGB(sTextureLightMap, vUv2);
    float lightmapM = textureIntensity(sTextureLightMapM, vUv2);
    vec3 lightmap = DecodeLightmapRGBM(sRGBToLinear(vec4(lightmapTexel, lightmapM)), vec2(34.0, 2.2));

    diffuse *= lightmap;
  #endif

  
  float materialSpecularf0 = mix(0.0, 0.08, uSpecularF0Factor);
  vec3 materialSpecularPBR = mix(vec3(materialSpecularf0), channelAlbedoPBR, channelMetalnessPBR);
  #ifdef CUBEMAP
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sSpecularPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #else
  #ifdef PANORAMA
  vec3 specular = computeIBLSpecularUE4(geoNormal, eyeVector, materialRoughness, materialSpecularPBR, transform, sPanoramaPBR, uTextureEnvironmentSpecularPBRLodRange, uTextureEnvironmentSpecularPBRTextureSize, normal);
  #endif
  #endif

  
  #if defined(OCCLUDE_SPECULAR) && defined(USE_LIGHTMAP)
    float factor = 3.;
    specular = mix(specular * 0.0, specular, clamp(min(lightmap, vec3(channelAOPBR)) * (factor * channelGlossinessPBR), 0.0, 1.0));
  #endif

  
  #ifdef USE_EMISSIVEMAP
  vec3 emissive = textureRGB(sTextureEmissiveMap, vUv.xy);
  #endif

  vec3 color = diffuse + specular;

  color *= uEnvironmentExposure;

  #ifdef USE_DIR_LIGHT
  vec4 prepSpec = LightingFuncPrep(geoNormal, eyeVector, materialRoughness);
  vec3 lightEyeDir = viewLightDir;
  float lightIntensity = 0.4;
  vec3 lightDiffuse = lightColor * lightIntensity;
  vec3 lightSpecular = computeSunLightPBRShading(geoNormal, eyeVector, materialDiffusePBR, prepSpec, materialSpecularPBR, lightDiffuse, lightEyeDir);

  float lmf = 1.0;

    #ifdef USE_LIGHTMAP
      lmf = clamp(pow(abs(luma(lightmap)), 4.0), 0.0, 1.0);
      lightSpecular = mix(vec3(0.0), lightSpecular, lmf);
    #endif

  if (highlights == 1) {
    color += lightSpecular;
  }
  #endif

  float channelOpacity = mix(albedoMap.a * uOpacityFactor, 1.0, luma(specular) * 2.0);

  #ifdef USE_EMISSIVEMAP
    color += sRGBToLinear(emissive);
  #endif

  if (uMode <= 0) {
    gl_FragColor = vec4(linearTosRGB(color), channelOpacity);
  } else if (uMode == 1) {
    gl_FragColor = vec4(linearTosRGB(geoNormal), 1.0);
  } else if (uMode == 2) {
    #ifdef USE_LIGHTMAP
    gl_FragColor = vec4(linearTosRGB(lightmap), 1.0);
    #else
    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #endif
  } else if (uMode == 3) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelAOPBR)), 1.0);
  } else if (uMode == 4) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelMetalnessPBR)), 1.0);
  } else if (uMode == 5) {
    gl_FragColor = vec4(linearTosRGB(vec3(channelGlossinessPBR)), 1.0);
  } else if (uMode == 6) {
    gl_FragColor = vec4(linearTosRGB(channelAlbedoPBR), 1.0);
  } else if (uMode == 7) {
    gl_FragColor = vec4(linearTosRGB(vec3(luminance)), 1.0);
  }

  #ifdef ALPHATEST
    if (gl_FragColor.a < uAlphaTest) {
      discard;
    } else {
      gl_FragColor.a = 1.0;
    }
  #endif
}
__ENDPROGRAM__

