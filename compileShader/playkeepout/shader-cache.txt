__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP


#define USE_LIGHTMAP



















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




#define USE_LIGHTMAP















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019























uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = vec4(position.x, position.y, 0.0, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 10
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG






















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP


#define USE_LIGHTMAP



















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




#define USE_LIGHTMAP















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SKINNED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1024
#define USE_MAP









#define USE_SKINNING
#define BONE_TEXTURE











uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define SKINNED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

varying float vPosX;

void main() {
  #ifdef USE_MAP
    vUv = uv;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / length( mvPosition.xyz ) );
  float sy = size * ( scale.y / length( mvPosition.xyz ) );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  if (i < 2) {
    vPosX = 0.0;
  } else {
    vPosX = 1.0;
  }

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
varying float vPosX;

#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 baseColor;
uniform vec3 fillColor;
uniform float opacity;
uniform float fullness;

void main() {
  gl_FragColor = vec4(baseColor, 1.0);

  float t = step(fullness, vPosX);

  gl_FragColor.xyz = mix(fillColor, baseColor, t);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv);
    gl_FragColor.a = texel1.a;
  #endif

  gl_FragColor.a *= opacity;

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = vec4(position.x, position.y, 0.0, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP


#define USE_LIGHTMAP



















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




#define USE_LIGHTMAP















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SKINNED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1024
#define USE_MAP









#define USE_SKINNING
#define BONE_TEXTURE











uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define SKINNED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

varying float vPosX;

void main() {
  #ifdef USE_MAP
    vUv = uv;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / length( mvPosition.xyz ) );
  float sy = size * ( scale.y / length( mvPosition.xyz ) );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  if (i < 2) {
    vPosX = 0.0;
  } else {
    vPosX = 1.0;
  }

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 12
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
varying float vPosX;

#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 baseColor;
uniform vec3 fillColor;
uniform float opacity;
uniform float fullness;

void main() {
  gl_FragColor = vec4(baseColor, 1.0);

  float t = step(fullness, vPosX);

  gl_FragColor.xyz = mix(fillColor, baseColor, t);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv);
    gl_FragColor.a = texel1.a;
  #endif

  gl_FragColor.a *= opacity;

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SKINNED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1024
#define USE_MAP









#define USE_SKINNING
#define BONE_TEXTURE











uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define SKINNED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP


#define USE_LIGHTMAP



















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




#define USE_LIGHTMAP















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
attribute float size;
attribute float opacity;

varying float vOpacity;

uniform float scale;

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
  vec4 mvPosition = viewMatrix * worldPosition;

  vOpacity = opacity;

  float dist = length(mvPosition.xyz);

  gl_PointSize = size;

  gl_Position = projectionMatrix * mvPosition;

  gl_PointSize = size * ( scale / dist );

  // reduce size of particles with distance
  // gl_PointSize = max(gl_PointSize - (abs(mvPosition.z) / 500.0), 0.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
varying float vOpacity;

uniform vec3 color;
uniform sampler2D map;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {

  gl_FragColor = vec4( color, vOpacity );

  gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define ALPHATEST 1


#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

varying float vPosX;

void main() {
  #ifdef USE_MAP
    vUv = uv;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / length( mvPosition.xyz ) );
  float sy = size * ( scale.y / length( mvPosition.xyz ) );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  if (i < 2) {
    vPosX = 0.0;
  } else {
    vPosX = 1.0;
  }

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
varying float vPosX;

#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 baseColor;
uniform vec3 fillColor;
uniform float opacity;
uniform float fullness;

void main() {
  gl_FragColor = vec4(baseColor, 1.0);

  float t = step(fullness, vPosX);

  gl_FragColor.xyz = mix(fillColor, baseColor, t);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv);
    gl_FragColor.a = texel1.a;
  #endif

  gl_FragColor.a *= opacity;

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019

#define USE_ENVMAP
#define ENVMAP_MODE_REFLECTION






#define FLAT_SHADED













uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vReflect;

uniform float refractionRatio;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
uniform float lightVariance;
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

vec3 transformDirection( in vec3 normal, in mat4 matrix ) {
    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );
}

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
        vLightBack += lightVariance / 250.0;
      #endif

      vLightFront += lightVariance / 250.0;
    }
  #endif

  vec3 objectNormal = normal;

  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );

  vec3 worldNormal = transformDirection( objectNormal, modelMatrix );

  vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

  vReflect = reflect( cameraToVertex, worldNormal );

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#extension GL_OES_standard_derivatives : enable
precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG


#define USE_ENVMAP
#define ENVMAP_TYPE_CUBE
#define ENVMAP_MODE_REFLECTION
#define ENVMAP_BLENDING_MULTIPLY






#define FLAT_SHADED









uniform mat4 viewMatrix;
uniform vec3 cameraPosition;

uniform float reflectivity;
uniform samplerCube envMap;
uniform float flipEnvMap;
varying vec3 vReflect;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

vec3 inputToLinear( in vec3 a ) {
#ifdef GAMMA_INPUT
    return pow( a, vec3( float( GAMMA_FACTOR ) ) );
#else
    return a;
#endif
}

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor = gl_FragColor * texelColor;
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
    // overlay(vLightFront);
    gl_FragColor.xyz *= vLightFront;
    else
    // overlay(vLightBack);
    gl_FragColor.xyz *= vLightBack;
    #else
    // overlay(vLightFront);
    gl_FragColor.xyz *= vLightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;


  vec3 reflectVec = vReflect;

  #ifdef DOUBLE_SIDED
      float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );
  #else
      float flipNormal = 1.0;
  #endif

  vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

  envColor.xyz = inputToLinear( envColor.xyz );

  float specularStrength = 1.0;

  vec3 outgoingLight = vec3(0.0);

  #ifdef ENVMAP_BLENDING_MULTIPLY
    gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * envColor.xyz, specularStrength * reflectivity);

  #elif defined( ENVMAP_BLENDING_MIX )

    gl_FragColor.rgb = mix( gl_FragColor.rgb, envColor.xyz, specularStrength * reflectivity );

  #elif defined( ENVMAP_BLENDING_ADD )

    gl_FragColor.rgb += envColor.xyz * specularStrength * reflectivity;

  #endif


  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 13
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP


#define USE_LIGHTMAP



















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define LIGHTMAP_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




#define USE_LIGHTMAP















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define USE_AOMAP true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define USE_AOMAP true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
attribute float size;
attribute float opacity;

varying float vOpacity;

uniform float scale;

void main() {
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
  vec4 mvPosition = viewMatrix * worldPosition;

  vOpacity = opacity;

  float dist = length(mvPosition.xyz);

  gl_PointSize = size;

  gl_Position = projectionMatrix * mvPosition;

  gl_PointSize = size * ( scale / dist );

  // reduce size of particles with distance
  // gl_PointSize = max(gl_PointSize - (abs(mvPosition.z) / 500.0), 0.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
varying float vOpacity;

uniform vec3 color;
uniform sampler2D map;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {

  gl_FragColor = vec4( color, vOpacity );

  gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define FOG_ENABLED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform vec4 offsetRepeat;
  uniform vec4 mapOffsetRepeat;
#endif

attribute float index;
uniform vec2 scale;
uniform float size;
uniform float aspectRatio;
uniform float scaleOffset;
uniform float animationDelay;

void main() {
  #ifdef USE_MAP
    vUv = uv;
    vUv2 = uv * mapOffsetRepeat.zw + mapOffsetRepeat.xy;
  #endif

  // Get vertex position in screen space
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

  // Animate worldPosition to create animation effect
  worldPosition.xyz *= scaleOffset;

  vec4 viewPosition = viewMatrix * worldPosition;
  vec4 pPosition = projectionMatrix * viewPosition;
  pPosition.xy /= pPosition.w;


  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  float sx = size * ( scale.x / -mvPosition.z );
  float sy = size * ( scale.y / -mvPosition.z );


  // Offset screen-space vertex position to create view-facing quad
  int i = int(index);
  if (i == 0) pPosition.xy += vec2(-sx * aspectRatio, sy);
  if (i == 1) pPosition.xy += vec2(-sx * aspectRatio, -sy);
  if (i == 2) pPosition.xy += vec2(sx * aspectRatio, sy);
  if (i == 3) pPosition.xy += vec2(sx * aspectRatio, -sy);

  // Convert position back to clip space
  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define FOG_ENABLED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;
  varying vec2 vUv2;
  uniform sampler2D map;
  uniform sampler2D map2;
#endif

uniform vec3 diffuse;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, 1.0);

  #ifdef USE_MAP
    vec4 texel1 = texture2D(map, vUv, -2.0);
    vec4 texel2 = texture2D(map2, vUv2, -2.0);
    gl_FragColor *= texel1;
    gl_FragColor = mix(gl_FragColor, texel2, texel2.a);
  #endif

  #ifdef FOG_ENABLED
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;
#define SKINNED true
#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1024
#define USE_MAP









#define USE_SKINNING
#define BONE_TEXTURE











uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;
#endif

#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#endif

#ifdef WRAP_AROUND
  uniform vec3 wrapRGB;
#endif

#ifdef SKINNED
  uniform mat4 bindMatrix;
  uniform mat4 bindMatrixInverse;

  uniform sampler2D boneTexture;
  uniform int boneTextureWidth;
  uniform int boneTextureHeight;

  mat4 getBoneMatrix(const in float i) {
    float j = i * 4.0;
    float x = mod( j, float( boneTextureWidth ) );
    float y = floor( j / float( boneTextureWidth ) );

    float dx = 1.0 / float( boneTextureWidth );
    float dy = 1.0 / float( boneTextureHeight );

    y = dy * ( y + 0.5 );

    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

    mat4 bone = mat4( v1, v2, v3, v4 );

    return bone;
  }
#endif

void main() {
  #ifdef SKINNED
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    skinned = bindMatrixInverse * skinned;

    vec4 mvPosition = modelViewMatrix * skinned;
  #else
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  #endif

  vec3 transformedNormal = normalMatrix * normal;

  gl_Position = projectionMatrix * mvPosition;

  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  #if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
    vUv2 = uv;
  #endif

  vLightFront = vec3( 0.0 );
  #ifdef DOUBLE_SIDED
  vLightBack = vec3( 0.0 );
  #endif

  #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
      vec3 lVector = lPosition.xyz - mvPosition.xyz;
      float lDistance = 1.0;

      if ( pointLightDistance[ i ] > 0.0 ) {
        lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
      }

      lVector = normalize( lVector );
      float dotProduct = dot( transformedNormal, lVector );
      vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );

      #ifdef DOUBLE_SIDED
        vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );
        #ifdef WRAP_AROUND
          vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );
        #endif
      #endif
      #ifdef WRAP_AROUND
        vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );
        pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );
        #ifdef DOUBLE_SIDED
          pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );
        #endif
      #endif
      vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;
      #ifdef DOUBLE_SIDED
        vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;
      #endif
    }
  #endif

  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;
#define SKINNED true
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform float lightVariance;

#ifdef USE_MAP
  varying vec2 vUv;
  uniform sampler2D map;
#endif

#if defined(USE_AOMAP) || defined(LIGHTMAP_ENABLED)
  varying vec2 vUv2;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
uniform float whiteness;

uniform vec3 overlayColor;
uniform float overlayBlend;

uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
  varying vec3 vLightBack;
#endif

#ifdef USE_AOMAP
  uniform float aoFactor;
  uniform sampler2D aoMap;
#endif

#ifdef LIGHTMAP_ENABLED
  uniform sampler2D lightMap;
#endif

void overlay(vec3 blend) {
  if (gl_FragColor.x < 0.5) {
      gl_FragColor.x = 2.0 * gl_FragColor.x * blend.x;
  } else {
      gl_FragColor.x = 1.0 - 2.0 * (1.0 - blend.x) * (1.0 - gl_FragColor.x);
  }

  if (gl_FragColor.y < 0.5) {
      gl_FragColor.y = 2.0 * gl_FragColor.y * blend.y;
  } else {
      gl_FragColor.y = 1.0 - 2.0 * (1.0 - blend.y) * (1.0 - gl_FragColor.y);
  }

  if (gl_FragColor.z < 0.5) {
      gl_FragColor.z = 2.0 * gl_FragColor.z * blend.z;
  } else {
      gl_FragColor.z = 1.0 - 2.0 * (1.0 - blend.z) * (1.0 - gl_FragColor.z);
  }
}

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv );

    gl_FragColor *= texelColor;
  #endif

  vec3 lightFront = vLightFront + (lightVariance / 4.0);

  #ifdef DOUBLE_SIDED
    if ( gl_FrontFacing )
      // overlay(lightFront);
      gl_FragColor.xyz *= lightFront;
    else
      // overlay(vLightBack);
      gl_FragColor.xyz *= vLightBack;
  #else
    // overlay(lightFront);
    gl_FragColor.xyz *= lightFront;
  #endif

  #ifdef USE_MAP
  vec3 emissiveColor = emissive * texelColor.xyz * diffuse;
  #else
  vec3 emissiveColor = emissive * diffuse;
  #endif
  gl_FragColor.xyz += emissiveColor;

  #ifdef LIGHTMAP_ENABLED
    gl_FragColor *= texture2D(lightMap, vUv2);
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayBlend);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  #ifdef USE_AOMAP
    vec4 aoTexel = texture2D(aoMap, vUv2);
    aoTexel.xyz = mix(aoTexel.xyz, vec3(1.0), vLightFront.r);

    gl_FragColor = mix(gl_FragColor, gl_FragColor * aoTexel, aoFactor);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < 0.75 ) discard;
  #endif
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP






















uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
#ifdef USE_MAP
  varying vec2 vUv;
  uniform vec4 offsetRepeat;
#endif

varying vec3 vPosition;

void main() {
  #ifdef USE_MAP
    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
  #endif

  vPosition = position;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2
#define USE_FOG

#define USE_MAP




















uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
varying vec3 vPosition;

#ifdef USE_MAP
  varying vec2 vUv;

  uniform sampler2D map;
#endif

uniform vec3 fogColor;

uniform vec3 diffuse;
uniform float opacity;
uniform float whiteness;

uniform float fogNear;
uniform float fogFar;

uniform float sparksPosition;

void main() {
  gl_FragColor = vec4(diffuse, opacity);

  #ifdef USE_MAP
    gl_FragColor = gl_FragColor * texture2D(map, vUv);
  #endif

  #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
  #endif

  float depth = gl_FragCoord.z / gl_FragCoord.w;
  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);

  gl_FragColor = mix(gl_FragColor, vec4(1.0), whiteness);

  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);

  if (vPosition.y > sparksPosition) {
    discard;
  }
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
precision highp float;
precision highp int;

#define VERTEX_TEXTURES


#define GAMMA_FACTOR 2
#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0
#define MAX_BONES 1019
#define USE_MAP














#define DOUBLE_SIDED







uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;
#ifdef USE_COLOR
    attribute vec3 color;
#endif
#ifdef USE_MORPHTARGETS
    attribute vec3 morphTarget0;
    attribute vec3 morphTarget1;
    attribute vec3 morphTarget2;
    attribute vec3 morphTarget3;
    #ifdef USE_MORPHNORMALS
        attribute vec3 morphNormal0;
        attribute vec3 morphNormal1;
        attribute vec3 morphNormal2;
        attribute vec3 morphNormal3;
    #else
        attribute vec3 morphTarget4;
        attribute vec3 morphTarget5;
        attribute vec3 morphTarget6;
        attribute vec3 morphTarget7;
    #endif
#endif
#ifdef USE_SKINNING
    attribute vec4 skinIndex;
    attribute vec4 skinWeight;
#endif
attribute float quadIndex;
attribute float timeDelay;

varying vec2 vUv;

uniform float timeElapsed;

const float quadSize = 0.035;
const float thickness = 0.01;
const float radius = 0.25;
const float speed = 0.35;

vec3 setLength(vec3 v, float l) {
  normalize(v);
  return v * l;
}

void main() {
  vUv = uv;

  float t = max(timeElapsed - timeDelay, 0.0);
  float offset = mod(t, radius) * speed;
  vec3 direction = vec3(position);
  vec3 pos = direction * offset;

  vec4 worldPos = modelMatrix * vec4(pos, 1.0);
  vec4 worldOrigin = worldPos;

  if (quadIndex == 3.0 || quadIndex == 1.0) {
    worldPos.xyz += (direction * quadSize);
  }

  if (quadIndex == 0.0 || quadIndex == 2.0) {
    worldPos.xyz -= (direction * quadSize);
  }

  vec4 viewPosition = viewMatrix * worldPos;
  vec4 pPosition = projectionMatrix * viewPosition;
  vec4 viewOrigin = viewMatrix * worldOrigin;
  vec4 pOrigin = projectionMatrix * viewOrigin;

  pPosition.xy /= pPosition.w;
  pOrigin.xy /= pOrigin.w;

  vec2 v = normalize(pOrigin.xy - pPosition.xy);
  vec2 w = vec2(-v.y, v.x) * thickness;
  w /= length(viewPosition);
  float s = 1.0;

  if (quadIndex == 0.0) {
    pPosition.xy += w / s;
  }

  if (quadIndex == 1.0) {
    pPosition.xy -= w / s;
  }

  if (quadIndex == 2.0) {
    pPosition.xy -= w / s;
  }

  if (quadIndex == 3.0) {
    pPosition.xy += w / s;
  }

  pPosition.xy *= pPosition.w;

  gl_Position = pPosition;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__

precision highp float;
precision highp int;

#define MAX_DIR_LIGHTS 0
#define MAX_POINT_LIGHTS 17
#define MAX_SPOT_LIGHTS 0
#define MAX_HEMI_LIGHTS 0
#define MAX_SHADOWS 0



#define GAMMA_FACTOR 2


#define USE_MAP













#define DOUBLE_SIDED






uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
varying vec2 vUv;

uniform vec3 color;
uniform sampler2D map;

void main() {
  gl_FragColor = vec4(color, 1.0);

  gl_FragColor *= texture2D(map, vUv);
  gl_FragColor.a = gl_FragColor.r;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__

