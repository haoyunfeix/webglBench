__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(short_mat_viewport)


attribute vec4 Vertex;
attribute vec4 Bones;
attribute vec4 Weights;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uBones[285];
uniform vec4 uHalton;

varying vec4 vViewVertex;


//////////////////////////////
// OPTIMIZED VERSION (NO IF)
//////////////////////////////
//#pragma DECLARE_FUNCTION
mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
    mat4 outMat_1;
    mat4 tmpMat_2;
    highp ivec4 tmpvar_3;
    tmpvar_3 = (3 * ivec4(bonesIndex));
    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    vec4 tmpvar_4;
    tmpvar_4 = -(abs(weights));
    tmpMat_2[0] = uBones[tmpvar_3.x];
    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];
    outMat_1 = ((float(
    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))
    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weights.x * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.y];
    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];
    outMat_1 = (outMat_1 + (weights.y * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.z];
    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];
    outMat_1 = (outMat_1 + (weights.z * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.w];
    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];
    outMat_1 = (outMat_1 + (weights.w * tmpMat_2));

    return outMat_1;
}

//////////////////////////////
// UN-OPTIMIZED VERSION (WITH IF)
//////////////////////////////

// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html
// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {
//     // We have to use a global variable because we can't access dynamically
//     // matrix is transpose so we should do vec * matrix
//     myMat[0] = uBones[ index ];
//     myMat[1] = uBones[ index + 1];
//     myMat[2] = uBones[ index + 2];
//     return myMat;
// }

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);
//     mat4 outMat = mat4(0.0);

//     // we handle negative weights
//     if(all(equal(weights, vec4(0.0)))) return tmpMat;

//     if(weights.x != 0.0) outMat += weights.x * getMat4FromVec4( idx.x, tmpMat );
//     if(weights.y != 0.0) outMat += weights.y * getMat4FromVec4( idx.y, tmpMat );
//     if(weights.z != 0.0) outMat += weights.z * getMat4FromVec4( idx.z, tmpMat );
//     if(weights.w != 0.0) outMat += weights.w * getMat4FromVec4( idx.w, tmpMat );
//     return outMat;
// }

//////////////////////////////
// UN-OPTIMIZED VERSION (NO IF)
//////////////////////////////

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);

//     // if sum is 0, return identity
//     vec4 absWeights = -abs(weights);
//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;

//     // we handle negative weights
//     // outMat[3][3] += weights.x + weights.y + weights.z + weights.w;

//     tmpMat[0] = uBones[ idx.x ];
//     tmpMat[1] = uBones[ idx.x + 1];
//     tmpMat[2] = uBones[ idx.x + 2];
//     outMat += weights.x * tmpMat;

//     tmpMat[0] = uBones[ idx.y ];
//     tmpMat[1] = uBones[ idx.y + 1];
//     tmpMat[2] = uBones[ idx.y + 2];
//     outMat += weights.y * tmpMat;

//     tmpMat[0] = uBones[ idx.z ];
//     tmpMat[1] = uBones[ idx.z + 1];
//     tmpMat[2] = uBones[ idx.z + 2];
//     outMat += weights.z * tmpMat;

//     tmpMat[0] = uBones[ idx.w ];
//     tmpMat[1] = uBones[ idx.w + 1];
//     tmpMat[2] = uBones[ idx.w + 2];
//     outMat += weights.w * tmpMat;

//     return outMat;
// }

void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 qVertex; vec3 skinVertex; mat4 boneMatrix;

// end vars

gl_PointSize = floatWhite;
boneMatrix = skinning( Weights, Bones );

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
skinVertex = vec3(vec4(qVertex.xyz, 1.)*boneMatrix);
viewVertex = uModelViewMatrix*vec4(skinVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(short_mat_viewport)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform vec4 uShadowDepthRange;

varying vec4 vViewVertex;



float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(short_mat_viewport)


attribute vec4 Vertex;
attribute vec4 Bones;
attribute vec4 Weights;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uBones[285];
uniform vec4 uHalton;

varying vec4 vViewVertex;


//////////////////////////////
// OPTIMIZED VERSION (NO IF)
//////////////////////////////
//#pragma DECLARE_FUNCTION
mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
    mat4 outMat_1;
    mat4 tmpMat_2;
    highp ivec4 tmpvar_3;
    tmpvar_3 = (3 * ivec4(bonesIndex));
    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    vec4 tmpvar_4;
    tmpvar_4 = -(abs(weights));
    tmpMat_2[0] = uBones[tmpvar_3.x];
    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];
    outMat_1 = ((float(
    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))
    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weights.x * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.y];
    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];
    outMat_1 = (outMat_1 + (weights.y * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.z];
    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];
    outMat_1 = (outMat_1 + (weights.z * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.w];
    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];
    outMat_1 = (outMat_1 + (weights.w * tmpMat_2));

    return outMat_1;
}

//////////////////////////////
// UN-OPTIMIZED VERSION (WITH IF)
//////////////////////////////

// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html
// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {
//     // We have to use a global variable because we can't access dynamically
//     // matrix is transpose so we should do vec * matrix
//     myMat[0] = uBones[ index ];
//     myMat[1] = uBones[ index + 1];
//     myMat[2] = uBones[ index + 2];
//     return myMat;
// }

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);
//     mat4 outMat = mat4(0.0);

//     // we handle negative weights
//     if(all(equal(weights, vec4(0.0)))) return tmpMat;

//     if(weights.x != 0.0) outMat += weights.x * getMat4FromVec4( idx.x, tmpMat );
//     if(weights.y != 0.0) outMat += weights.y * getMat4FromVec4( idx.y, tmpMat );
//     if(weights.z != 0.0) outMat += weights.z * getMat4FromVec4( idx.z, tmpMat );
//     if(weights.w != 0.0) outMat += weights.w * getMat4FromVec4( idx.w, tmpMat );
//     return outMat;
// }

//////////////////////////////
// UN-OPTIMIZED VERSION (NO IF)
//////////////////////////////

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);

//     // if sum is 0, return identity
//     vec4 absWeights = -abs(weights);
//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;

//     // we handle negative weights
//     // outMat[3][3] += weights.x + weights.y + weights.z + weights.w;

//     tmpMat[0] = uBones[ idx.x ];
//     tmpMat[1] = uBones[ idx.x + 1];
//     tmpMat[2] = uBones[ idx.x + 2];
//     outMat += weights.x * tmpMat;

//     tmpMat[0] = uBones[ idx.y ];
//     tmpMat[1] = uBones[ idx.y + 1];
//     tmpMat[2] = uBones[ idx.y + 2];
//     outMat += weights.y * tmpMat;

//     tmpMat[0] = uBones[ idx.z ];
//     tmpMat[1] = uBones[ idx.z + 1];
//     tmpMat[2] = uBones[ idx.z + 2];
//     outMat += weights.z * tmpMat;

//     tmpMat[0] = uBones[ idx.w ];
//     tmpMat[1] = uBones[ idx.w + 1];
//     tmpMat[2] = uBones[ idx.w + 2];
//     outMat += weights.w * tmpMat;

//     return outMat;
// }

void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 qVertex; vec3 skinVertex; mat4 boneMatrix;

// end vars

gl_PointSize = floatWhite;
boneMatrix = skinning( Weights, Bones );

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
skinVertex = vec3(vec4(qVertex.xyz, 1.)*boneMatrix);
viewVertex = uModelViewMatrix*vec4(skinVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(short_mat_viewport)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform vec4 uShadowDepthRange;

varying vec4 vViewVertex;



float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(body_mat_viewport)


attribute vec3 Vertex;
attribute vec3 Vertex_0;
attribute vec3 Vertex_1;
attribute vec3 Vertex_2;
attribute vec3 Vertex_3;
attribute vec4 Bones;
attribute vec4 Weights;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec4 uBones[285];
uniform vec4 uHalton;
uniform vec4 uTargetWeights;

varying vec4 vViewVertex;


//////////////////////////////
// OPTIMIZED VERSION (NO IF)
//////////////////////////////
//#pragma DECLARE_FUNCTION
mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
    mat4 outMat_1;
    mat4 tmpMat_2;
    highp ivec4 tmpvar_3;
    tmpvar_3 = (3 * ivec4(bonesIndex));
    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    vec4 tmpvar_4;
    tmpvar_4 = -(abs(weights));
    tmpMat_2[0] = uBones[tmpvar_3.x];
    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];
    outMat_1 = ((float(
    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))
    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weights.x * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.y];
    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];
    outMat_1 = (outMat_1 + (weights.y * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.z];
    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];
    outMat_1 = (outMat_1 + (weights.z * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.w];
    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];
    outMat_1 = (outMat_1 + (weights.w * tmpMat_2));

    return outMat_1;
}

//////////////////////////////
// UN-OPTIMIZED VERSION (WITH IF)
//////////////////////////////

// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html
// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {
//     // We have to use a global variable because we can't access dynamically
//     // matrix is transpose so we should do vec * matrix
//     myMat[0] = uBones[ index ];
//     myMat[1] = uBones[ index + 1];
//     myMat[2] = uBones[ index + 2];
//     return myMat;
// }

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);
//     mat4 outMat = mat4(0.0);

//     // we handle negative weights
//     if(all(equal(weights, vec4(0.0)))) return tmpMat;

//     if(weights.x != 0.0) outMat += weights.x * getMat4FromVec4( idx.x, tmpMat );
//     if(weights.y != 0.0) outMat += weights.y * getMat4FromVec4( idx.y, tmpMat );
//     if(weights.z != 0.0) outMat += weights.z * getMat4FromVec4( idx.z, tmpMat );
//     if(weights.w != 0.0) outMat += weights.w * getMat4FromVec4( idx.w, tmpMat );
//     return outMat;
// }

//////////////////////////////
// UN-OPTIMIZED VERSION (NO IF)
//////////////////////////////

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);

//     // if sum is 0, return identity
//     vec4 absWeights = -abs(weights);
//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;

//     // we handle negative weights
//     // outMat[3][3] += weights.x + weights.y + weights.z + weights.w;

//     tmpMat[0] = uBones[ idx.x ];
//     tmpMat[1] = uBones[ idx.x + 1];
//     tmpMat[2] = uBones[ idx.x + 2];
//     outMat += weights.x * tmpMat;

//     tmpMat[0] = uBones[ idx.y ];
//     tmpMat[1] = uBones[ idx.y + 1];
//     tmpMat[2] = uBones[ idx.y + 2];
//     outMat += weights.y * tmpMat;

//     tmpMat[0] = uBones[ idx.z ];
//     tmpMat[1] = uBones[ idx.z + 1];
//     tmpMat[2] = uBones[ idx.z + 2];
//     outMat += weights.z * tmpMat;

//     tmpMat[0] = uBones[ idx.w ];
//     tmpMat[1] = uBones[ idx.w + 1];
//     tmpMat[2] = uBones[ idx.w + 2];
//     outMat += weights.w * tmpMat;

//     return outMat;
// }

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0) {

    return mix(vertex, target0, weights[0]);
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2) {
  
    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2,
        const in vec3 target3) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2] + weights[3]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    vecOut += target3 * weights[3];
    return vecOut;
}

void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 morphVertex; vec3 skinVertex; mat4 boneMatrix;

// end vars

gl_PointSize = floatWhite;
boneMatrix = skinning( Weights, Bones );

morphVertex = morphing( uTargetWeights, Vertex, Vertex_0, Vertex_1, Vertex_2, Vertex_3 );

skinVertex = vec3(vec4(morphVertex.xyz, 1.)*boneMatrix);
viewVertex = uModelViewMatrix*vec4(skinVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(body_mat_viewport)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform vec4 uShadowDepthRange;

varying vec4 vViewVertex;



float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_MaskDither(hair_mat_view)


attribute vec4 Vertex;
attribute vec2 TexCoord1;
attribute vec4 Bones;
attribute vec4 Weights;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uBones[285];
uniform vec4 uHalton;
uniform vec4 uQUV1;

varying vec2 vTexCoord1;
varying vec4 vViewVertex;


//////////////////////////////
// OPTIMIZED VERSION (NO IF)
//////////////////////////////
//#pragma DECLARE_FUNCTION
mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
    mat4 outMat_1;
    mat4 tmpMat_2;
    highp ivec4 tmpvar_3;
    tmpvar_3 = (3 * ivec4(bonesIndex));
    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    vec4 tmpvar_4;
    tmpvar_4 = -(abs(weights));
    tmpMat_2[0] = uBones[tmpvar_3.x];
    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];
    outMat_1 = ((float(
    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))
    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weights.x * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.y];
    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];
    outMat_1 = (outMat_1 + (weights.y * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.z];
    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];
    outMat_1 = (outMat_1 + (weights.z * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.w];
    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];
    outMat_1 = (outMat_1 + (weights.w * tmpMat_2));

    return outMat_1;
}

//////////////////////////////
// UN-OPTIMIZED VERSION (WITH IF)
//////////////////////////////

// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html
// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {
//     // We have to use a global variable because we can't access dynamically
//     // matrix is transpose so we should do vec * matrix
//     myMat[0] = uBones[ index ];
//     myMat[1] = uBones[ index + 1];
//     myMat[2] = uBones[ index + 2];
//     return myMat;
// }

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);
//     mat4 outMat = mat4(0.0);

//     // we handle negative weights
//     if(all(equal(weights, vec4(0.0)))) return tmpMat;

//     if(weights.x != 0.0) outMat += weights.x * getMat4FromVec4( idx.x, tmpMat );
//     if(weights.y != 0.0) outMat += weights.y * getMat4FromVec4( idx.y, tmpMat );
//     if(weights.z != 0.0) outMat += weights.z * getMat4FromVec4( idx.z, tmpMat );
//     if(weights.w != 0.0) outMat += weights.w * getMat4FromVec4( idx.w, tmpMat );
//     return outMat;
// }

//////////////////////////////
// UN-OPTIMIZED VERSION (NO IF)
//////////////////////////////

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);

//     // if sum is 0, return identity
//     vec4 absWeights = -abs(weights);
//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;

//     // we handle negative weights
//     // outMat[3][3] += weights.x + weights.y + weights.z + weights.w;

//     tmpMat[0] = uBones[ idx.x ];
//     tmpMat[1] = uBones[ idx.x + 1];
//     tmpMat[2] = uBones[ idx.x + 2];
//     outMat += weights.x * tmpMat;

//     tmpMat[0] = uBones[ idx.y ];
//     tmpMat[1] = uBones[ idx.y + 1];
//     tmpMat[2] = uBones[ idx.y + 2];
//     outMat += weights.y * tmpMat;

//     tmpMat[0] = uBones[ idx.z ];
//     tmpMat[1] = uBones[ idx.z + 1];
//     tmpMat[2] = uBones[ idx.z + 2];
//     outMat += weights.z * tmpMat;

//     tmpMat[0] = uBones[ idx.w ];
//     tmpMat[1] = uBones[ idx.w + 1];
//     tmpMat[2] = uBones[ idx.w + 2];
//     outMat += weights.w * tmpMat;

//     return outMat;
// }

void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 qVertex; vec3 skinVertex; mat4 boneMatrix; vec2 qTexCoord1;

// end vars

gl_PointSize = floatWhite;
boneMatrix = skinning( Weights, Bones );

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
skinVertex = vec3(vec4(qVertex.xyz, 1.)*boneMatrix);
viewVertex = uModelViewMatrix*vec4(skinVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
qTexCoord1 = (TexCoord1.xy * uQUV1.zw) + uQUV1.xy;
vTexCoord1 = qTexCoord1;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_MaskDither(hair_mat_view)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform float uFrameMod;
uniform float uOpacityFactor;
uniform float uOpacityThinLayer;
uniform int uOpacityDithering;
uniform int uOpacityInvert;
uniform sampler2D Texture0;
uniform vec2 uNearFar;
uniform vec4 uHalton;
uniform vec4 uShadowDepthRange;

varying vec2 vTexCoord1;
varying vec4 vViewVertex;



// white vs interleaved vs blue noise
// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/

// to test in a shadertoy
// https://www.shadertoy.com/view/lsdfD4

// https://www.shadertoy.com/view/4djSRW
// most combinations are possible : in[1,2,3] -> out[1,2,3]
#define INT_SCALE1 .1031
float pseudoRandom(const in vec2 fragCoord) {
    vec3 p3  = fract(vec3(fragCoord.xyx) * INT_SCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27
float interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MaterialTemplate.ush#L1863
// we slighty change it by multiplying by 1.2 (to match with other noise), otherwise the range seems to be between [0 - 0.83]
float ditheringNoise(const in vec2 fragCoord, const in float frameMod) {
    // float fm = mod(frameMod, 2.0) == 0.0 ? 1.0 : -1.0;
    float fm = frameMod;
    float dither5 = fract((fragCoord.x + fragCoord.y * 2.0 - 1.5 + fm) / 5.0);
    float noise = fract(dot(vec2(171.0, 231.0) / 71.0, fragCoord.xy));
    return (dither5 * 5.0 + noise) * (1.2 / 6.0);
}

//#pragma DECLARE_FUNCTION
void ditheringMaskingDiscard(
    const in vec4 fragCoord,
    const in int dithering,
    const in float alpha,
    const in float factor,

    const in float thinLayer,

    const in float frameMod,
    const in vec2 nearFar,

    const in vec4 halton) {

    if (dithering != 1) {
        if (alpha < factor) discard;
        return;
    }

    float rnd;

    if (thinLayer == 0.0) {
        float linZ = (1.0 / fragCoord.w - nearFar.x) / (nearFar.y - nearFar.x);
        float sliceZ = floor(linZ * 500.0) / 500.0;
        rnd = interleavedGradientNoise(fragCoord.xy + sliceZ, frameMod);
    } else {
        rnd = pseudoRandom(fragCoord.xy + halton.xy * 1000.0 + fragCoord.z * (abs(halton.z) == 2.0 ? 1000.0 : 1.0));
    }

    if (alpha * factor < rnd) discard;
}


float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
// vars

float channelOpacity; float OpacityFetch; float tmp_4; vec4 tmp_8 = gl_FragCoord;

// end vars

OpacityFetch = texture2D(Texture0, vTexCoord1).a;
tmp_4 = uOpacityInvert == 1 ? 1.0 - OpacityFetch : OpacityFetch;
channelOpacity = tmp_4;
ditheringMaskingDiscard( tmp_8, uOpacityDithering, channelOpacity, uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton );

gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(mouth_mat_viewport)


attribute vec4 Vertex;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uHalton;

varying vec4 vViewVertex;



void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 qVertex;

// end vars

gl_PointSize = floatWhite;
qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
viewVertex = uModelViewMatrix*vec4(qVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(mouth_mat_viewport)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform vec4 uShadowDepthRange;

varying vec4 vViewVertex;



float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(eyebrows_mat_view)


attribute vec3 Vertex;
attribute vec3 Vertex_0;
attribute vec3 Vertex_1;
attribute vec3 Vertex_2;
attribute vec3 Vertex_3;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec4 uHalton;
uniform vec4 uTargetWeights;

varying vec4 vViewVertex;


//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0) {

    return mix(vertex, target0, weights[0]);
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2) {
  
    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2,
        const in vec3 target3) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2] + weights[3]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    vecOut += target3 * weights[3];
    return vecOut;
}

void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 morphVertex;

// end vars

gl_PointSize = floatWhite;
morphVertex = morphing( uTargetWeights, Vertex, Vertex_0, Vertex_1, Vertex_2, Vertex_3 );

viewVertex = uModelViewMatrix*vec4(morphVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(eyebrows_mat_view)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform vec4 uShadowDepthRange;

varying vec4 vViewVertex;



float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(eye_mat_view)


attribute vec3 Vertex;
attribute vec3 Vertex_0;
attribute vec3 Vertex_1;
attribute vec3 Vertex_2;
attribute vec3 Vertex_3;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec4 uHalton;
uniform vec4 uTargetWeights;

varying vec4 vViewVertex;


//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0) {

    return mix(vertex, target0, weights[0]);
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2) {
  
    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2,
        const in vec3 target3) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2] + weights[3]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    vecOut += target3 * weights[3];
    return vecOut;
}

void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 morphVertex;

// end vars

gl_PointSize = floatWhite;
morphVertex = morphing( uTargetWeights, Vertex, Vertex_0, Vertex_1, Vertex_2, Vertex_3 );

viewVertex = uModelViewMatrix*vec4(morphVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Opaque(eye_mat_view)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform vec4 uShadowDepthRange;

varying vec4 vViewVertex;



float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Blend(lambert1)


attribute vec4 Vertex;
attribute vec2 TexCoord0;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uShadowMapSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uHalton;
uniform vec4 uQUV0;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;



void main() {
// vars

const float floatWhite = float(1.0); mat4 jitteredProjection; vec4 viewVertex; vec3 qVertex; vec2 qTexCoord0;

// end vars

gl_PointSize = floatWhite;
qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
viewVertex = uModelViewMatrix*vec4(qVertex.xyz, 1.);
jitteredProjection = uProjectionMatrix;
float doPersp = jitteredProjection[3][3] == 0.0 ? 1.0 : 0.0;
vec2 jitter = (abs(uHalton.z) == 2.0 ? 1.0 : 0.0) * (uHalton.xy / uShadowMapSize.xy);
jitteredProjection[2].xy += doPersp * jitter;
jitteredProjection[3].xy += (1.0 - doPersp) * jitter;
gl_Position = jitteredProjection*viewVertex;
qTexCoord0 = (TexCoord0.xy * uQUV0.zw) + uQUV0.xy;
vTexCoord0 = qTexCoord0;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME ShadowCastSkfb_Blend(lambert1)
#define _ATLAS_SHADOW
#define _JITTER_OFFSET
#define _PCFx1


uniform float uOpacityFactor;
uniform int uOpacityInvert;
uniform sampler2D Texture0;
uniform vec4 uShadowDepthRange;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;



float decodeFloatRGBA( vec4 rgba ) {
    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
}

vec4 encodeFloatRGBA( float v ) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
    return enc;
}

vec2 decodeHalfFloatRGBA( vec4 rgba ) {
    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));
}

vec4 encodeHalfFloatRGBA( vec2 v ) {
    const vec2 bias = vec2(1.0 / 255.0, 0.0);
    vec4 enc;
    enc.xy = vec2(v.x, fract(v.x * 255.0));
    enc.xy = enc.xy - (enc.yy * bias);

    enc.zw = vec2(v.y, fract(v.y * 255.0));
    enc.zw = enc.zw - (enc.ww * bias);
    return enc;
}


//#pragma DECLARE_FUNCTION
vec4 shadowCast(const in vec4 fragEye, const in vec2 shadowDepthRange){
    // distance to camera (we make sure we are near 0 and in [0,1])
    float depth = (-fragEye.z * fragEye.w - shadowDepthRange.x) / (shadowDepthRange.y - shadowDepthRange.x);

#ifdef _FLOATTEX
    return vec4(depth, 0.0, 0.0, 1.0);
#else
    return encodeFloatRGBA(depth);
#endif
}

void main() {
// vars

float channelOpacity; float OpacityFetch; float tmp_4;

// end vars

OpacityFetch = texture2D(Texture0, vTexCoord0).r;
tmp_4 = uOpacityInvert == 1 ? 1.0 - OpacityFetch : OpacityFetch;
channelOpacity = tmp_4*uOpacityFactor;
if(channelOpacity < 1.0) discard;
gl_FragColor = shadowCast( vViewVertex, uShadowDepthRange.rg );

  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME MaterialPacker
attribute vec3 Vertex;
varying vec2 vTexCoord0;

void main(void) {
    gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
    vTexCoord0 = Vertex.xy;
}

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME MaterialPacker
uniform sampler2D uTexture0;
uniform sampler2D uTexture1;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

// vec4 (up to 4 textures input)
// int meaning :
// 0 -> read R
// 1 -> read A
// 2 -> read RGB
uniform ivec4 uReadPacking;

varying vec2 vTexCoord0;

void main(void) {
    // check if we are in a 2 or 4 texture packing pattern
    if ( uReadPacking.x == 3 ) {
        gl_FragColor.rgb = texture2D( uTexture0, vTexCoord0 ).aaa;
        gl_FragColor.a = uReadPacking.y == 0 ? texture2D( uTexture1, vTexCoord0 ).r : texture2D( uTexture1, vTexCoord0 ).a;

    } else if ( uReadPacking.x == 2 ) {
        gl_FragColor.rgb = texture2D( uTexture0, vTexCoord0 ).rgb;
        gl_FragColor.a = uReadPacking.y == 0 ? texture2D( uTexture1, vTexCoord0 ).r : texture2D( uTexture1, vTexCoord0 ).a;

    } else {
        gl_FragColor.r = uReadPacking.x == 0 ? texture2D( uTexture0, vTexCoord0 ).r : texture2D( uTexture0, vTexCoord0 ).a;
        gl_FragColor.g = uReadPacking.y == 0 ? texture2D( uTexture1, vTexCoord0 ).r : texture2D( uTexture1, vTexCoord0 ).a;
        gl_FragColor.b = uReadPacking.z == 0 ? texture2D( uTexture2, vTexCoord0 ).r : texture2D( uTexture2, vTexCoord0 ).a;
        gl_FragColor.a = uReadPacking.w == 0 ? texture2D( uTexture3, vTexCoord0 ).r : texture2D( uTexture3, vTexCoord0 ).a;
    }
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME MaterialPacker
attribute vec3 Vertex;
varying vec2 vTexCoord0;

void main(void) {
    gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
    vTexCoord0 = Vertex.xy;
}

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME MaterialPacker
uniform sampler2D uTexture0;
uniform sampler2D uTexture1;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

// vec4 (up to 4 textures input)
// int meaning :
// 0 -> read R
// 1 -> read A
// 2 -> read RGB
uniform ivec4 uReadPacking;

varying vec2 vTexCoord0;

void main(void) {
    // check if we are in a 2 or 4 texture packing pattern
    if ( uReadPacking.x == 3 ) {
        gl_FragColor.rgb = texture2D( uTexture0, vTexCoord0 ).aaa;
        gl_FragColor.a = uReadPacking.y == 0 ? texture2D( uTexture1, vTexCoord0 ).r : texture2D( uTexture1, vTexCoord0 ).a;

    } else if ( uReadPacking.x == 2 ) {
        gl_FragColor.rgb = texture2D( uTexture0, vTexCoord0 ).rgb;
        gl_FragColor.a = uReadPacking.y == 0 ? texture2D( uTexture1, vTexCoord0 ).r : texture2D( uTexture1, vTexCoord0 ).a;

    } else {
        gl_FragColor.r = uReadPacking.x == 0 ? texture2D( uTexture0, vTexCoord0 ).r : texture2D( uTexture0, vTexCoord0 ).a;
        gl_FragColor.g = uReadPacking.y == 0 ? texture2D( uTexture1, vTexCoord0 ).r : texture2D( uTexture1, vTexCoord0 ).a;
        gl_FragColor.b = uReadPacking.z == 0 ? texture2D( uTexture2, vTexCoord0 ).r : texture2D( uTexture2, vTexCoord0 ).a;
        gl_FragColor.a = uReadPacking.w == 0 ? texture2D( uTexture3, vTexCoord0 ).r : texture2D( uTexture3, vTexCoord0 ).a;
    }
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(body_mat_viewport)


attribute vec3 Vertex;
attribute vec2 TexCoord0;
attribute vec3 Vertex_0;
attribute vec3 Vertex_1;
attribute vec3 Vertex_2;
attribute vec3 Vertex_3;
attribute vec4 Bones;
attribute vec4 Weights;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec4 uBones[285];
uniform vec4 uHalton;
uniform vec4 uQUV0;
uniform vec4 uTargetWeights;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;


//////////////////////////////
// OPTIMIZED VERSION (NO IF)
//////////////////////////////
//#pragma DECLARE_FUNCTION
mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
    mat4 outMat_1;
    mat4 tmpMat_2;
    highp ivec4 tmpvar_3;
    tmpvar_3 = (3 * ivec4(bonesIndex));
    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    vec4 tmpvar_4;
    tmpvar_4 = -(abs(weights));
    tmpMat_2[0] = uBones[tmpvar_3.x];
    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];
    outMat_1 = ((float(
    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))
    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weights.x * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.y];
    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];
    outMat_1 = (outMat_1 + (weights.y * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.z];
    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];
    outMat_1 = (outMat_1 + (weights.z * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.w];
    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];
    outMat_1 = (outMat_1 + (weights.w * tmpMat_2));

    return outMat_1;
}

//////////////////////////////
// UN-OPTIMIZED VERSION (WITH IF)
//////////////////////////////

// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html
// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {
//     // We have to use a global variable because we can't access dynamically
//     // matrix is transpose so we should do vec * matrix
//     myMat[0] = uBones[ index ];
//     myMat[1] = uBones[ index + 1];
//     myMat[2] = uBones[ index + 2];
//     return myMat;
// }

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);
//     mat4 outMat = mat4(0.0);

//     // we handle negative weights
//     if(all(equal(weights, vec4(0.0)))) return tmpMat;

//     if(weights.x != 0.0) outMat += weights.x * getMat4FromVec4( idx.x, tmpMat );
//     if(weights.y != 0.0) outMat += weights.y * getMat4FromVec4( idx.y, tmpMat );
//     if(weights.z != 0.0) outMat += weights.z * getMat4FromVec4( idx.z, tmpMat );
//     if(weights.w != 0.0) outMat += weights.w * getMat4FromVec4( idx.w, tmpMat );
//     return outMat;
// }

//////////////////////////////
// UN-OPTIMIZED VERSION (NO IF)
//////////////////////////////

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);

//     // if sum is 0, return identity
//     vec4 absWeights = -abs(weights);
//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;

//     // we handle negative weights
//     // outMat[3][3] += weights.x + weights.y + weights.z + weights.w;

//     tmpMat[0] = uBones[ idx.x ];
//     tmpMat[1] = uBones[ idx.x + 1];
//     tmpMat[2] = uBones[ idx.x + 2];
//     outMat += weights.x * tmpMat;

//     tmpMat[0] = uBones[ idx.y ];
//     tmpMat[1] = uBones[ idx.y + 1];
//     tmpMat[2] = uBones[ idx.y + 2];
//     outMat += weights.y * tmpMat;

//     tmpMat[0] = uBones[ idx.z ];
//     tmpMat[1] = uBones[ idx.z + 1];
//     tmpMat[2] = uBones[ idx.z + 2];
//     outMat += weights.z * tmpMat;

//     tmpMat[0] = uBones[ idx.w ];
//     tmpMat[1] = uBones[ idx.w + 1];
//     tmpMat[2] = uBones[ idx.w + 2];
//     outMat += weights.w * tmpMat;

//     return outMat;
// }

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0) {

    return mix(vertex, target0, weights[0]);
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2) {
  
    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2,
        const in vec3 target3) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2] + weights[3]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    vecOut += target3 * weights[3];
    return vecOut;
}

void main() {
// vars

vec4 viewVertex; vec3 morphVertex; vec3 skinVertex; mat4 boneMatrix; mat4 jitteredProjection; vec2 qTexCoord0;

// end vars

boneMatrix = skinning( Weights, Bones );

morphVertex = morphing( uTargetWeights, Vertex, Vertex_0, Vertex_1, Vertex_2, Vertex_3 );

skinVertex = vec3(vec4(morphVertex.xyz, 1.)*boneMatrix);
viewVertex = uModelViewMatrix*vec4(skinVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
qTexCoord0 = (TexCoord0.xy * uQUV0.zw) + uQUV0.xy;
vTexCoord0 = qTexCoord0;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(body_mat_viewport)


uniform float uScatteringFactorPacker;
uniform float uSubsurfaceScatteringFactor;
uniform float uSubsurfaceScatteringProfile;
uniform sampler2D Texture0;
uniform vec2 uNearFar;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

vec4 tmp_0; float tmp_1; float channelSubsurfaceScattering; float SubsurfaceScatteringFetch; float tmp_10; float tmp_12 = float(1.0);

// end vars

tmp_1 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
SubsurfaceScatteringFetch = texture2D(Texture0, vTexCoord0).a;
channelSubsurfaceScattering = SubsurfaceScatteringFetch*uSubsurfaceScatteringFactor;
tmp_10 = channelSubsurfaceScattering*uScatteringFactorPacker;
tmp_0 = encodeDepthAlphaProfileScatter( tmp_1, tmp_12, uSubsurfaceScatteringProfile, tmp_10 );

gl_FragColor = tmp_0;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_MaskDither(hair_mat_view)


attribute vec4 Vertex;
attribute vec2 TexCoord1;
attribute vec4 Bones;
attribute vec4 Weights;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uBones[285];
uniform vec4 uHalton;
uniform vec4 uQUV1;

varying vec2 vTexCoord1;
varying vec4 vViewVertex;


//////////////////////////////
// OPTIMIZED VERSION (NO IF)
//////////////////////////////
//#pragma DECLARE_FUNCTION
mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
    mat4 outMat_1;
    mat4 tmpMat_2;
    highp ivec4 tmpvar_3;
    tmpvar_3 = (3 * ivec4(bonesIndex));
    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    vec4 tmpvar_4;
    tmpvar_4 = -(abs(weights));
    tmpMat_2[0] = uBones[tmpvar_3.x];
    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];
    outMat_1 = ((float(
    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))
    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weights.x * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.y];
    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];
    outMat_1 = (outMat_1 + (weights.y * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.z];
    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];
    outMat_1 = (outMat_1 + (weights.z * tmpMat_2));
    tmpMat_2[0] = uBones[tmpvar_3.w];
    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];
    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];
    outMat_1 = (outMat_1 + (weights.w * tmpMat_2));

    return outMat_1;
}

//////////////////////////////
// UN-OPTIMIZED VERSION (WITH IF)
//////////////////////////////

// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html
// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {
//     // We have to use a global variable because we can't access dynamically
//     // matrix is transpose so we should do vec * matrix
//     myMat[0] = uBones[ index ];
//     myMat[1] = uBones[ index + 1];
//     myMat[2] = uBones[ index + 2];
//     return myMat;
// }

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);
//     mat4 outMat = mat4(0.0);

//     // we handle negative weights
//     if(all(equal(weights, vec4(0.0)))) return tmpMat;

//     if(weights.x != 0.0) outMat += weights.x * getMat4FromVec4( idx.x, tmpMat );
//     if(weights.y != 0.0) outMat += weights.y * getMat4FromVec4( idx.y, tmpMat );
//     if(weights.z != 0.0) outMat += weights.z * getMat4FromVec4( idx.z, tmpMat );
//     if(weights.w != 0.0) outMat += weights.w * getMat4FromVec4( idx.w, tmpMat );
//     return outMat;
// }

//////////////////////////////
// UN-OPTIMIZED VERSION (NO IF)
//////////////////////////////

// mat4 skinning( const in vec4 weights, const in vec4 bonesIndex ) {
//     ivec4 idx =  3 * ivec4(bonesIndex);
//     mat4 tmpMat = mat4(1.0);

//     // if sum is 0, return identity
//     vec4 absWeights = -abs(weights);
//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;

//     // we handle negative weights
//     // outMat[3][3] += weights.x + weights.y + weights.z + weights.w;

//     tmpMat[0] = uBones[ idx.x ];
//     tmpMat[1] = uBones[ idx.x + 1];
//     tmpMat[2] = uBones[ idx.x + 2];
//     outMat += weights.x * tmpMat;

//     tmpMat[0] = uBones[ idx.y ];
//     tmpMat[1] = uBones[ idx.y + 1];
//     tmpMat[2] = uBones[ idx.y + 2];
//     outMat += weights.y * tmpMat;

//     tmpMat[0] = uBones[ idx.z ];
//     tmpMat[1] = uBones[ idx.z + 1];
//     tmpMat[2] = uBones[ idx.z + 2];
//     outMat += weights.z * tmpMat;

//     tmpMat[0] = uBones[ idx.w ];
//     tmpMat[1] = uBones[ idx.w + 1];
//     tmpMat[2] = uBones[ idx.w + 2];
//     outMat += weights.w * tmpMat;

//     return outMat;
// }

void main() {
// vars

vec4 viewVertex; vec3 qVertex; vec3 skinVertex; mat4 boneMatrix; mat4 jitteredProjection; vec2 qTexCoord1;

// end vars

boneMatrix = skinning( Weights, Bones );

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
skinVertex = vec3(vec4(qVertex.xyz, 1.)*boneMatrix);
viewVertex = uModelViewMatrix*vec4(skinVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
qTexCoord1 = (TexCoord1.xy * uQUV1.zw) + uQUV1.xy;
vTexCoord1 = qTexCoord1;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_MaskDither(hair_mat_view)


uniform float uFrameMod;
uniform float uOpacityFactor;
uniform float uOpacityThinLayer;
uniform float uScatteringFactorPacker;
uniform float uSubsurfaceScatteringFactor;
uniform float uSubsurfaceScatteringProfile;
uniform int uOpacityDithering;
uniform int uOpacityInvert;
uniform sampler2D Texture0;
uniform vec2 uNearFar;
uniform vec4 uHalton;

varying vec2 vTexCoord1;
varying vec4 vViewVertex;



// white vs interleaved vs blue noise
// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/

// to test in a shadertoy
// https://www.shadertoy.com/view/lsdfD4

// https://www.shadertoy.com/view/4djSRW
// most combinations are possible : in[1,2,3] -> out[1,2,3]
#define INT_SCALE1 .1031
float pseudoRandom(const in vec2 fragCoord) {
    vec3 p3  = fract(vec3(fragCoord.xyx) * INT_SCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27
float interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MaterialTemplate.ush#L1863
// we slighty change it by multiplying by 1.2 (to match with other noise), otherwise the range seems to be between [0 - 0.83]
float ditheringNoise(const in vec2 fragCoord, const in float frameMod) {
    // float fm = mod(frameMod, 2.0) == 0.0 ? 1.0 : -1.0;
    float fm = frameMod;
    float dither5 = fract((fragCoord.x + fragCoord.y * 2.0 - 1.5 + fm) / 5.0);
    float noise = fract(dot(vec2(171.0, 231.0) / 71.0, fragCoord.xy));
    return (dither5 * 5.0 + noise) * (1.2 / 6.0);
}

//#pragma DECLARE_FUNCTION
void ditheringMaskingDiscard(
    const in vec4 fragCoord,
    const in int dithering,
    const in float alpha,
    const in float factor,

    const in float thinLayer,

    const in float frameMod,
    const in vec2 nearFar,

    const in vec4 halton) {

    if (dithering != 1) {
        if (alpha < factor) discard;
        return;
    }

    float rnd;

    if (thinLayer == 0.0) {
        float linZ = (1.0 / fragCoord.w - nearFar.x) / (nearFar.y - nearFar.x);
        float sliceZ = floor(linZ * 500.0) / 500.0;
        rnd = interleavedGradientNoise(fragCoord.xy + sliceZ, frameMod);
    } else {
        rnd = pseudoRandom(fragCoord.xy + halton.xy * 1000.0 + fragCoord.z * (abs(halton.z) == 2.0 ? 1000.0 : 1.0));
    }

    if (alpha * factor < rnd) discard;
}

// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

float channelOpacity; float OpacityFetch; float tmp_4; vec4 tmp_8 = gl_FragCoord; vec4 tmp_13; float tmp_14; float channelSubsurfaceScattering; float tmp_17 = float(1.0); float tmp_20; float tmp_22 = float(1.0);

// end vars

OpacityFetch = texture2D(Texture0, vTexCoord1).a;
tmp_4 = uOpacityInvert == 1 ? 1.0 - OpacityFetch : OpacityFetch;
channelOpacity = tmp_4;
ditheringMaskingDiscard( tmp_8, uOpacityDithering, channelOpacity, uOpacityFactor, uOpacityThinLayer, uFrameMod, uNearFar, uHalton );

tmp_14 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
channelSubsurfaceScattering = tmp_17*uSubsurfaceScatteringFactor;
tmp_20 = channelSubsurfaceScattering*uScatteringFactorPacker;
tmp_13 = encodeDepthAlphaProfileScatter( tmp_14, tmp_22, uSubsurfaceScatteringProfile, tmp_20 );

gl_FragColor = tmp_13;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(mouth_mat_viewport)


attribute vec4 Vertex;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uHalton;

varying vec4 vViewVertex;



void main() {
// vars

vec4 viewVertex; vec3 qVertex; mat4 jitteredProjection;

// end vars

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
viewVertex = uModelViewMatrix*vec4(qVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(mouth_mat_viewport)


uniform float uScatteringFactorPacker;
uniform float uSubsurfaceScatteringFactor;
uniform float uSubsurfaceScatteringProfile;
uniform vec2 uNearFar;

varying vec4 vViewVertex;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

vec4 tmp_0; float tmp_1; float channelSubsurfaceScattering; float tmp_5 = float(1.0); float tmp_8; float tmp_10 = float(1.0);

// end vars

tmp_1 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
channelSubsurfaceScattering = tmp_5*uSubsurfaceScatteringFactor;
tmp_8 = channelSubsurfaceScattering*uScatteringFactorPacker;
tmp_0 = encodeDepthAlphaProfileScatter( tmp_1, tmp_10, uSubsurfaceScatteringProfile, tmp_8 );

gl_FragColor = tmp_0;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(eyebrows_mat_view)


attribute vec3 Vertex;
attribute vec3 Vertex_0;
attribute vec3 Vertex_1;
attribute vec3 Vertex_2;
attribute vec3 Vertex_3;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec4 uHalton;
uniform vec4 uTargetWeights;

varying vec4 vViewVertex;


//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0) {

    return mix(vertex, target0, weights[0]);
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2) {
  
    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2,
        const in vec3 target3) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2] + weights[3]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    vecOut += target3 * weights[3];
    return vecOut;
}

void main() {
// vars

vec4 viewVertex; vec3 morphVertex; mat4 jitteredProjection;

// end vars

morphVertex = morphing( uTargetWeights, Vertex, Vertex_0, Vertex_1, Vertex_2, Vertex_3 );

viewVertex = uModelViewMatrix*vec4(morphVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(eyebrows_mat_view)


uniform vec2 uNearFar;

varying vec4 vViewVertex;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

vec4 tmp_0; float tmp_1; float tmp_4 = float(0.0); float tmp_5 = float(0.0); float tmp_6 = float(1.0);

// end vars

tmp_1 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
tmp_0 = encodeDepthAlphaProfileScatter( tmp_1, tmp_6, tmp_4, tmp_5 );

gl_FragColor = tmp_0;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(eye_mat_view)


attribute vec3 Vertex;
attribute vec2 TexCoord0;
attribute vec3 Vertex_0;
attribute vec3 Vertex_1;
attribute vec3 Vertex_2;
attribute vec3 Vertex_3;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec4 uHalton;
uniform vec4 uQUV0;
uniform vec4 uTargetWeights;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;


//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0) {

    return mix(vertex, target0, weights[0]);
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2) {
  
    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    return vecOut;
}

//#pragma DECLARE_FUNCTION
vec3 morphing(
        const in vec4 weights,
        const in vec3 vertex,
        const in vec3 target0,
        const in vec3 target1,
        const in vec3 target2,
        const in vec3 target3) {

    vec3 vecOut = vertex * (1.0 - ( weights[0] + weights[1] + weights[2] + weights[3]));
    vecOut += target0 * weights[0];
    vecOut += target1 * weights[1];
    vecOut += target2 * weights[2];
    vecOut += target3 * weights[3];
    return vecOut;
}

void main() {
// vars

vec4 viewVertex; vec3 morphVertex; mat4 jitteredProjection; vec2 qTexCoord0;

// end vars

morphVertex = morphing( uTargetWeights, Vertex, Vertex_0, Vertex_1, Vertex_2, Vertex_3 );

viewVertex = uModelViewMatrix*vec4(morphVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
qTexCoord0 = (TexCoord0.xy * uQUV0.zw) + uQUV0.xy;
vTexCoord0 = qTexCoord0;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Opaque(eye_mat_view)


uniform float uScatteringFactorPacker;
uniform float uSubsurfaceScatteringFactor;
uniform float uSubsurfaceScatteringProfile;
uniform sampler2D Texture0;
uniform vec2 uNearFar;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

vec4 tmp_0; float tmp_1; float channelSubsurfaceScattering; float SubsurfaceScatteringFetch; float tmp_10; float tmp_12 = float(1.0);

// end vars

tmp_1 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
SubsurfaceScatteringFetch = texture2D(Texture0, vTexCoord0).a;
channelSubsurfaceScattering = SubsurfaceScatteringFetch*uSubsurfaceScatteringFactor;
tmp_10 = channelSubsurfaceScattering*uScatteringFactorPacker;
tmp_0 = encodeDepthAlphaProfileScatter( tmp_1, tmp_12, uSubsurfaceScatteringProfile, tmp_10 );

gl_FragColor = tmp_0;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Blend(lambert1)


attribute vec4 Vertex;
attribute vec2 TexCoord0;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uHalton;
uniform vec4 uQUV0;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;



void main() {
// vars

vec4 viewVertex; vec3 qVertex; mat4 jitteredProjection; vec2 qTexCoord0;

// end vars

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
viewVertex = uModelViewMatrix*vec4(qVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
qTexCoord0 = (TexCoord0.xy * uQUV0.zw) + uQUV0.xy;
vTexCoord0 = qTexCoord0;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Blend(lambert1)


uniform float uOpacityFactor;
uniform int uDrawOpaque;
uniform int uOpacityInvert;
uniform sampler2D Texture0;
uniform vec2 uNearFar;

varying vec2 vTexCoord0;
varying vec4 vViewVertex;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

float channelOpacity; float OpacityFetch; float tmp_4; vec4 tmp_8; float tmp_9; float tmp_12 = float(0.0); float tmp_13 = float(0.0); float tmp_14;

// end vars

OpacityFetch = texture2D(Texture0, vTexCoord0).r;
tmp_4 = uOpacityInvert == 1 ? 1.0 - OpacityFetch : OpacityFetch;
channelOpacity = tmp_4*uOpacityFactor;
if(uDrawOpaque == 1 && channelOpacity < 9.9999e-1) discard;
tmp_9 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
tmp_14 = uDrawOpaque == 1 ? 1.0 : channelOpacity;
tmp_8 = encodeDepthAlphaProfileScatter( tmp_9, tmp_14, tmp_12, tmp_13 );

gl_FragColor = tmp_8;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Blend(cornea_mat_view)


attribute vec4 Vertex;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uHalton;

varying vec4 vViewVertex;



void main() {
// vars

vec4 viewVertex; vec3 qVertex; mat4 jitteredProjection;

// end vars

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
viewVertex = uModelViewMatrix*vec4(qVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Blend(cornea_mat_view)


uniform float uOpacityFactor;
uniform int uDrawOpaque;
uniform vec2 uNearFar;

varying vec4 vViewVertex;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

float channelOpacity; float tmp_1 = float(1.0); vec4 tmp_4; float tmp_5; float tmp_8 = float(0.0); float tmp_9 = float(0.0); float tmp_10;

// end vars

channelOpacity = tmp_1*uOpacityFactor;
if(uDrawOpaque == 1 && channelOpacity < 9.9999e-1) discard;
tmp_5 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
tmp_10 = uDrawOpaque == 1 ? 1.0 : channelOpacity;
tmp_4 = encodeDepthAlphaProfileScatter( tmp_5, tmp_10, tmp_8, tmp_9 );

gl_FragColor = tmp_4;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Blend(cornea_mat_view)


attribute vec4 Vertex;

uniform float uDisplay2D;
uniform float uPointSize;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec2 uGlobalTexRatio;
uniform vec2 uGlobalTexSize;
uniform vec3 uQVS;
uniform vec3 uQVT;
uniform vec4 uHalton;

varying vec4 vViewVertex;



void main() {
// vars

vec4 viewVertex; vec3 qVertex; mat4 jitteredProjection;

// end vars

qVertex = ((Vertex.xyz+ Vertex.w) * uQVS *vec3(1.2436648109348014e+0,4.4577023636992745e+0,5.49836675761659e+0).yzx) + uQVT;
viewVertex = uModelViewMatrix*vec4(qVertex.xyz, 1.);
gl_PointSize = min(64.0, max(1.0, -uPointSize / viewVertex.z));
jitteredProjection = uProjectionMatrix;
jitteredProjection[2].xy += (1.0 - uDisplay2D) * (uHalton.xy * uGlobalTexRatio.xy / uGlobalTexSize.xy);
gl_Position = jitteredProjection*viewVertex;
vViewVertex = viewVertex;
  gl_Position.x += CONST_SHADER_RECACHE;
}
__FRAGMENTSHADER__
#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
#define SHADER_NAME earlyZ_Blend(cornea_mat_view)


uniform float uOpacityFactor;
uniform int uDrawOpaque;
uniform vec2 uNearFar;

varying vec4 vViewVertex;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
void main() {
// vars

float channelOpacity; float tmp_1 = float(1.0); vec4 tmp_4; float tmp_5; float tmp_8 = float(0.0); float tmp_9 = float(0.0); float tmp_10;

// end vars

channelOpacity = tmp_1*uOpacityFactor;
if(uDrawOpaque == 1 && channelOpacity < 9.9999e-1) discard;
tmp_5 = (-vViewVertex.z - uNearFar.x) / (uNearFar.y - uNearFar.x);
tmp_10 = uDrawOpaque == 1 ? 1.0 : channelOpacity;
tmp_4 = encodeDepthAlphaProfileScatter( tmp_5, tmp_10, tmp_8, tmp_9 );

gl_FragColor = tmp_4;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureMipmapDepth

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureDepth0;
uniform sampler2D TextureDepth1;
uniform sampler2D TextureDepth2;
uniform sampler2D TextureDepth3;
uniform sampler2D TextureDepth4;
uniform sampler2D TextureDepth5;
uniform vec2 uTextureDepth0Size;
uniform vec2 uTextureDepth0Ratio;
uniform vec2 uTextureDepth1Size;
uniform vec2 uTextureDepth1Ratio;
uniform vec2 uTextureDepth2Size;
uniform vec2 uTextureDepth2Ratio;
uniform vec2 uTextureDepth3Size;
uniform vec2 uTextureDepth3Ratio;
uniform vec2 uTextureDepth4Size;
uniform vec2 uTextureDepth4Ratio;
uniform vec2 uTextureDepth5Size;
uniform vec2 uTextureDepth5Ratio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureDepth0(uv) (texture2D(TextureDepth0, (min(uv, 1.0 - 1e+0 / uTextureDepth0Size.xy)) * uTextureDepth0Ratio))
#define TEXTURE_2D_TextureDepth1(uv) (texture2D(TextureDepth1, (min(uv, 1.0 - 1e+0 / uTextureDepth1Size.xy)) * uTextureDepth1Ratio))
#define TEXTURE_2D_TextureDepth2(uv) (texture2D(TextureDepth2, (min(uv, 1.0 - 1e+0 / uTextureDepth2Size.xy)) * uTextureDepth2Ratio))
#define TEXTURE_2D_TextureDepth3(uv) (texture2D(TextureDepth3, (min(uv, 1.0 - 1e+0 / uTextureDepth3Size.xy)) * uTextureDepth3Ratio))
#define TEXTURE_2D_TextureDepth4(uv) (texture2D(TextureDepth4, (min(uv, 1.0 - 1e+0 / uTextureDepth4Size.xy)) * uTextureDepth4Ratio))
#define TEXTURE_2D_TextureDepth5(uv) (texture2D(TextureDepth5, (min(uv, 1.0 - 1e+0 / uTextureDepth5Size.xy)) * uTextureDepth5Ratio))



#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}


vec4 packMipmapDepth() {
    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);

    // see _hookComposerResize in NodePostProcess.js (mipmap)
    gTexCoord.y /= uTextureOutputRatio.y;

    float levelLog = -log2(1.0 - gTexCoord.y) + 1.0;
    float level = floor(levelLog) - 1.0;

    float pLevel = pow(2.0, level + 1.0); // 2, 4, 8, 16...
    gTexCoord.x = pLevel * gTexCoord.x * 0.5;
    gTexCoord.y = pLevel * (1.0 - gTexCoord.y) - 1.0;

    // unused part of the texture
    if (gTexCoord.x > 1.0 || gTexCoord.y > 1.0) return result;

    if (level < 0.1) result.rgba = vec4(encode24(decodeDepth(TEXTURE_2D_TextureDepth0(gTexCoord))), 1.0);
    else if (level < 1.1) result.rgba = TEXTURE_2D_TextureDepth1(gTexCoord);
    else if (level < 2.1) result.rgba = TEXTURE_2D_TextureDepth2(gTexCoord);
    else if (level < 3.1) result.rgba = TEXTURE_2D_TextureDepth3(gTexCoord);
    else if (level < 4.1) result.rgba = TEXTURE_2D_TextureDepth4(gTexCoord);
    else if (level < 5.1) result.rgba = TEXTURE_2D_TextureDepth5(gTexCoord);

    return result;
}



void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = packMipmapDepth();


    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureMipmapDepth

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureSsaoExtract

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureMipmapDepth;
uniform vec2 uTextureMipmapDepthSize;
uniform vec2 uTextureMipmapDepthRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#extension GL_OES_standard_derivatives : enable

#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))




#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}

// white vs interleaved vs blue noise
// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/

// to test in a shadertoy
// https://www.shadertoy.com/view/lsdfD4

// https://www.shadertoy.com/view/4djSRW
// most combinations are possible : in[1,2,3] -> out[1,2,3]
#define INT_SCALE1 .1031
float pseudoRandom(const in vec2 fragCoord) {
    vec3 p3  = fract(vec3(fragCoord.xyx) * INT_SCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27
float interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MaterialTemplate.ush#L1863
// we slighty change it by multiplying by 1.2 (to match with other noise), otherwise the range seems to be between [0 - 0.83]
float ditheringNoise(const in vec2 fragCoord, const in float frameMod) {
    // float fm = mod(frameMod, 2.0) == 0.0 ? 1.0 : -1.0;
    float fm = frameMod;
    float dither5 = fract((fragCoord.x + fragCoord.y * 2.0 - 1.5 + fm) / 5.0);
    float noise = fract(dot(vec2(171.0, 231.0) / 71.0, fragCoord.xy));
    return (dither5 * 5.0 + noise) * (1.2 / 6.0);
}

//#pragma DECLARE_FUNCTION
void ditheringMaskingDiscard(
    const in vec4 fragCoord,
    const in int dithering,
    const in float alpha,
    const in float factor,

    const in float thinLayer,

    const in float frameMod,
    const in vec2 nearFar,

    const in vec4 halton) {

    if (dithering != 1) {
        if (alpha < factor) discard;
        return;
    }

    float rnd;

    if (thinLayer == 0.0) {
        float linZ = (1.0 / fragCoord.w - nearFar.x) / (nearFar.y - nearFar.x);
        float sliceZ = floor(linZ * 500.0) / 500.0;
        rnd = interleavedGradientNoise(fragCoord.xy + sliceZ, frameMod);
    } else {
        rnd = pseudoRandom(fragCoord.xy + halton.xy * 1000.0 + fragCoord.z * (abs(halton.z) == 2.0 ? 1000.0 : 1.0));
    }

    if (alpha * factor < rnd) discard;
}



uniform float uQuality; // mipmap usage


uniform float uSsaoRadius;
uniform float uSsaoIntensity;
uniform float uSsaoBias;
uniform vec4 uSsaoProjectionInfo;
uniform float uSsaoProjectionScale;

uniform vec2 uNearFar;

uniform float uFrameModTaaSS;

// Constant used to scale the depth view value that is given to the blur pass
#define MIN_RADIUS 1.0
#define NB_SPIRAL_TURNS 3.0

vec4 fetchDepthPackLevel(const in vec2 uv, const in float level){
    float maxLod = 5.0;
    float powLevel = pow(2.0, min(maxLod, floor(level)) + 1.0);
    vec2 pixelSize = 2.0 * powLevel / uTextureMipmapDepthSize;

    vec2 uvFetch = max(pixelSize, min(1.0 - pixelSize, uv));
    uvFetch = vec2(2.0 * uvFetch.x, powLevel - 1.0 - uvFetch.y) * uTextureMipmapDepthRatio.xy / powLevel;

    return texture2D(TextureMipmapDepth, uvFetch);
}

float fetchDepthLevel(const in vec2 uv, const in float level){
    return decode24(fetchDepthPackLevel(uv, level).xyz);
}

float zValueFromScreenSpacePosition(const in float depth) {
    return uNearFar.x + (uNearFar.y - uNearFar.x) * depth;
}

vec3 reconstructCSPosition(const in vec2 ssP, const in float z) {
    return vec3((ssP.xy * uSsaoProjectionInfo.xy + uSsaoProjectionInfo.zw) * z, z);
}

vec3 getPosition(const in vec2 uv) {
    return reconstructCSPosition(uv * uTextureOutputSize, zValueFromScreenSpacePosition(fetchDepthLevel(uv, 0.0)));
}

#define MAX_MIP_LEVEL 5
// Determines at which point we should switch mip level
// if number is too small (~3) will lead to flashing (bad variance as many taps give same pixel)
// if number is too high, mip level are not used well and the cache is not used efficiently
#define LOG_MAX_OFFSET 3

vec3 getOffsetedPixelPos(
    const in vec2 uv,
    const in vec2 unitOffset,
    const in float screenSpaceRadius) {

    float mipLevel = clamp(floor(log2(screenSpaceRadius)) - float(LOG_MAX_OFFSET), 0.0, float(MAX_MIP_LEVEL));
    vec2 uvOff = uv + floor(screenSpaceRadius * unitOffset) / uTextureOutputSize;

    float d = zValueFromScreenSpacePosition(fetchDepthLevel(uvOff, mipLevel));
    return reconstructCSPosition(uvOff * uTextureOutputSize, d);
}

#define PIOVER8 0.39269908169
vec3 unpackNormal1(const in float pack1) {
    float pack8 = floor(pack1 * 255.0);
    float th = PIOVER8 * float(pack8 / 16.0);
    float len = sqrt(mod(float(pack8), 16.0) / 15.001);
    vec2 nv = vec2(cos(th), sin(th)) * len;
    return -vec3(nv.x, nv.y, sqrt(max(0.0, 1.0 - nv.x * nv.x - nv.y * nv.y)));
}

vec3 unpackNormal2(const in vec2 pack2) {
    vec3 nv = pack2.rgg * 2.0 - 1.0;
    return -vec3(nv.x, nv.y, sqrt(max(0.0, 1.0 - nv.x * nv.x - nv.y * nv.y)));
}

#define SSAO_TAP_EXTRACT(id) screenSpaceRadius = (float(id) + 0.5) * (1.0 / nbSamples);     angle = screenSpaceRadius * (NB_SPIRAL_TURNS * 6.28) + randomAngle;     screenSpaceRadius = max(0.75, screenSpaceRadius * ssRadius);     offsetUnitVec = vec2(cos(angle), sin(angle));     occludingPoint = getOffsetedPixelPos(uv, offsetUnitVec, screenSpaceRadius);     occludingPoint -= cameraSpacePosition;     vv = dot(occludingPoint, occludingPoint);     vn = dot(occludingPoint, normal);     contrib += max(1.0 - vv * invRadius2, 0.0) * max((vn - uSsaoBias) * inversesqrt(vv), 0.0); 
#define SSAO_DO_TAPS(void) SSAO_TAP_EXTRACT(offset + 0);     SSAO_TAP_EXTRACT(offset + 1);     SSAO_TAP_EXTRACT(offset + 2);     SSAO_TAP_EXTRACT(offset + 3);     SSAO_TAP_EXTRACT(offset + 4);     SSAO_TAP_EXTRACT(offset + 5);     SSAO_TAP_EXTRACT(offset + 6);     SSAO_TAP_EXTRACT(offset + 7);     SSAO_TAP_EXTRACT(offset + 8);     SSAO_TAP_EXTRACT(offset + 9);     SSAO_TAP_EXTRACT(offset + 10);     offset += 11; 

vec4 ssaoExtract() {
    vec2 uv = gTexCoord;

    vec3 depthPacked = fetchDepthPackLevel(uv, 0.0).xyz;

    vec3 cameraSpacePosition = getPosition(uv);
    float ssRadius = -uSsaoProjectionScale * uSsaoRadius / cameraSpacePosition.z;

#ifdef SSAO_NORMAL
    vec3 normal = unpackNormal2(TEXTURE_2D_TextureDepth(uv).ba); // g buffer normal 2 component on ba
#elif defined(GL_OES_standard_derivatives) && !defined(MOBILE)
    vec3 normal = cross(dFdy(cameraSpacePosition), dFdx(cameraSpacePosition));
#else
    vec2 offDepth = vec2(1.0, 0.0);
    vec3 depthLeft = getPosition(uv - offDepth.xy / uTextureMipmapDepthSize);
    vec3 depthRight = getPosition(uv + offDepth.xy / uTextureMipmapDepthSize);
    vec3 depthBottom = getPosition(uv - offDepth.yx / uTextureMipmapDepthSize);
    vec3 depthTop = getPosition(uv + offDepth.yx / uTextureMipmapDepthSize);
    vec3 normal = cross(depthLeft - depthRight, depthTop - depthBottom);
#endif

    // early returns should be done derivatives usage to avoid bad edges

    // early return background
    if (depthPacked.x == 1.0) {
        return vec4(depthPacked, 1.0);
    }

    // early return radius too small (note: needs to be in separate conditional because of nvidia/osx bug)
    if (ssRadius < MIN_RADIUS) {
        return vec4(depthPacked, 1.0);
    }

    normal = normalize(normal);
    float nFalloff = mix(1.0, max(0.0, 1.5 * normal.z), 0.35);

     // needs to be > 2PI
    float randomAngle = 6.28 * interleavedGradientNoise(gl_FragCoord.xy, uFrameModTaaSS);
   
    float invRadius2 = 1.0 / (uSsaoRadius * uSsaoRadius);
    float contrib = 0.0;

    float vv;
    float vn;
    float screenSpaceRadius;
    float angle;
    vec3 occludingPoint;
    vec2 offsetUnitVec;
    int offset = 0;

    float nbSamples = 11.0;
    if (uQuality > 0.33) nbSamples += 11.0;
    if (uQuality > 0.66) nbSamples += 11.0;

    SSAO_DO_TAPS();
    if (uQuality > 0.33) { SSAO_DO_TAPS(); }
    if (uQuality > 0.66) { SSAO_DO_TAPS(); }

    float aoValue = max(0.0, 1.0 - sqrt(contrib * nFalloff / nbSamples));
    aoValue = pow(aoValue, 10.0 * uSsaoIntensity);

    vec4 aoDepth;
    aoDepth.rgb = depthPacked;
    aoDepth.a = mix(1.0, aoValue, clamp(ssRadius - MIN_RADIUS, 0.0, 1.0));

    return aoDepth;
}



void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = ssaoExtract();


    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureSsaoExtract

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureSsaoExtract

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureMipmapDepth;
uniform vec2 uTextureMipmapDepthSize;
uniform vec2 uTextureMipmapDepthRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#extension GL_OES_standard_derivatives : enable

#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))




#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}

// white vs interleaved vs blue noise
// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/

// to test in a shadertoy
// https://www.shadertoy.com/view/lsdfD4

// https://www.shadertoy.com/view/4djSRW
// most combinations are possible : in[1,2,3] -> out[1,2,3]
#define INT_SCALE1 .1031
float pseudoRandom(const in vec2 fragCoord) {
    vec3 p3  = fract(vec3(fragCoord.xyx) * INT_SCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27
float interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MaterialTemplate.ush#L1863
// we slighty change it by multiplying by 1.2 (to match with other noise), otherwise the range seems to be between [0 - 0.83]
float ditheringNoise(const in vec2 fragCoord, const in float frameMod) {
    // float fm = mod(frameMod, 2.0) == 0.0 ? 1.0 : -1.0;
    float fm = frameMod;
    float dither5 = fract((fragCoord.x + fragCoord.y * 2.0 - 1.5 + fm) / 5.0);
    float noise = fract(dot(vec2(171.0, 231.0) / 71.0, fragCoord.xy));
    return (dither5 * 5.0 + noise) * (1.2 / 6.0);
}

//#pragma DECLARE_FUNCTION
void ditheringMaskingDiscard(
    const in vec4 fragCoord,
    const in int dithering,
    const in float alpha,
    const in float factor,

    const in float thinLayer,

    const in float frameMod,
    const in vec2 nearFar,

    const in vec4 halton) {

    if (dithering != 1) {
        if (alpha < factor) discard;
        return;
    }

    float rnd;

    if (thinLayer == 0.0) {
        float linZ = (1.0 / fragCoord.w - nearFar.x) / (nearFar.y - nearFar.x);
        float sliceZ = floor(linZ * 500.0) / 500.0;
        rnd = interleavedGradientNoise(fragCoord.xy + sliceZ, frameMod);
    } else {
        rnd = pseudoRandom(fragCoord.xy + halton.xy * 1000.0 + fragCoord.z * (abs(halton.z) == 2.0 ? 1000.0 : 1.0));
    }

    if (alpha * factor < rnd) discard;
}



uniform float uQuality; // mipmap usage


uniform float uSsaoRadius;
uniform float uSsaoIntensity;
uniform float uSsaoBias;
uniform vec4 uSsaoProjectionInfo;
uniform float uSsaoProjectionScale;

uniform vec2 uNearFar;

uniform float uFrameModTaaSS;

// Constant used to scale the depth view value that is given to the blur pass
#define MIN_RADIUS 1.0
#define NB_SPIRAL_TURNS 3.0

vec4 fetchDepthPackLevel(const in vec2 uv, const in float level){
    float maxLod = 5.0;
    float powLevel = pow(2.0, min(maxLod, floor(level)) + 1.0);
    vec2 pixelSize = 2.0 * powLevel / uTextureMipmapDepthSize;

    vec2 uvFetch = max(pixelSize, min(1.0 - pixelSize, uv));
    uvFetch = vec2(2.0 * uvFetch.x, powLevel - 1.0 - uvFetch.y) * uTextureMipmapDepthRatio.xy / powLevel;

    return texture2D(TextureMipmapDepth, uvFetch);
}

float fetchDepthLevel(const in vec2 uv, const in float level){
    return decode24(fetchDepthPackLevel(uv, level).xyz);
}

float zValueFromScreenSpacePosition(const in float depth) {
    return uNearFar.x + (uNearFar.y - uNearFar.x) * depth;
}

vec3 reconstructCSPosition(const in vec2 ssP, const in float z) {
    return vec3((ssP.xy * uSsaoProjectionInfo.xy + uSsaoProjectionInfo.zw) * z, z);
}

vec3 getPosition(const in vec2 uv) {
    return reconstructCSPosition(uv * uTextureOutputSize, zValueFromScreenSpacePosition(fetchDepthLevel(uv, 0.0)));
}

#define MAX_MIP_LEVEL 5
// Determines at which point we should switch mip level
// if number is too small (~3) will lead to flashing (bad variance as many taps give same pixel)
// if number is too high, mip level are not used well and the cache is not used efficiently
#define LOG_MAX_OFFSET 3

vec3 getOffsetedPixelPos(
    const in vec2 uv,
    const in vec2 unitOffset,
    const in float screenSpaceRadius) {

    float mipLevel = clamp(floor(log2(screenSpaceRadius)) - float(LOG_MAX_OFFSET), 0.0, float(MAX_MIP_LEVEL));
    vec2 uvOff = uv + floor(screenSpaceRadius * unitOffset) / uTextureOutputSize;

    float d = zValueFromScreenSpacePosition(fetchDepthLevel(uvOff, mipLevel));
    return reconstructCSPosition(uvOff * uTextureOutputSize, d);
}

#define PIOVER8 0.39269908169
vec3 unpackNormal1(const in float pack1) {
    float pack8 = floor(pack1 * 255.0);
    float th = PIOVER8 * float(pack8 / 16.0);
    float len = sqrt(mod(float(pack8), 16.0) / 15.001);
    vec2 nv = vec2(cos(th), sin(th)) * len;
    return -vec3(nv.x, nv.y, sqrt(max(0.0, 1.0 - nv.x * nv.x - nv.y * nv.y)));
}

vec3 unpackNormal2(const in vec2 pack2) {
    vec3 nv = pack2.rgg * 2.0 - 1.0;
    return -vec3(nv.x, nv.y, sqrt(max(0.0, 1.0 - nv.x * nv.x - nv.y * nv.y)));
}

#define SSAO_TAP_EXTRACT(id) screenSpaceRadius = (float(id) + 0.5) * (1.0 / nbSamples);     angle = screenSpaceRadius * (NB_SPIRAL_TURNS * 6.28) + randomAngle;     screenSpaceRadius = max(0.75, screenSpaceRadius * ssRadius);     offsetUnitVec = vec2(cos(angle), sin(angle));     occludingPoint = getOffsetedPixelPos(uv, offsetUnitVec, screenSpaceRadius);     occludingPoint -= cameraSpacePosition;     vv = dot(occludingPoint, occludingPoint);     vn = dot(occludingPoint, normal);     contrib += max(1.0 - vv * invRadius2, 0.0) * max((vn - uSsaoBias) * inversesqrt(vv), 0.0); 
#define SSAO_DO_TAPS(void) SSAO_TAP_EXTRACT(offset + 0);     SSAO_TAP_EXTRACT(offset + 1);     SSAO_TAP_EXTRACT(offset + 2);     SSAO_TAP_EXTRACT(offset + 3);     SSAO_TAP_EXTRACT(offset + 4);     SSAO_TAP_EXTRACT(offset + 5);     SSAO_TAP_EXTRACT(offset + 6);     SSAO_TAP_EXTRACT(offset + 7);     SSAO_TAP_EXTRACT(offset + 8);     SSAO_TAP_EXTRACT(offset + 9);     SSAO_TAP_EXTRACT(offset + 10);     offset += 11; 

vec4 ssaoExtract() {
    vec2 uv = gTexCoord;

    vec3 depthPacked = fetchDepthPackLevel(uv, 0.0).xyz;

    vec3 cameraSpacePosition = getPosition(uv);
    float ssRadius = -uSsaoProjectionScale * uSsaoRadius / cameraSpacePosition.z;

#ifdef SSAO_NORMAL
    vec3 normal = unpackNormal2(TEXTURE_2D_TextureDepth(uv).ba); // g buffer normal 2 component on ba
#elif defined(GL_OES_standard_derivatives) && !defined(MOBILE)
    vec3 normal = cross(dFdy(cameraSpacePosition), dFdx(cameraSpacePosition));
#else
    vec2 offDepth = vec2(1.0, 0.0);
    vec3 depthLeft = getPosition(uv - offDepth.xy / uTextureMipmapDepthSize);
    vec3 depthRight = getPosition(uv + offDepth.xy / uTextureMipmapDepthSize);
    vec3 depthBottom = getPosition(uv - offDepth.yx / uTextureMipmapDepthSize);
    vec3 depthTop = getPosition(uv + offDepth.yx / uTextureMipmapDepthSize);
    vec3 normal = cross(depthLeft - depthRight, depthTop - depthBottom);
#endif

    // early returns should be done derivatives usage to avoid bad edges

    // early return background
    if (depthPacked.x == 1.0) {
        return vec4(depthPacked, 1.0);
    }

    // early return radius too small (note: needs to be in separate conditional because of nvidia/osx bug)
    if (ssRadius < MIN_RADIUS) {
        return vec4(depthPacked, 1.0);
    }

    normal = normalize(normal);
    float nFalloff = mix(1.0, max(0.0, 1.5 * normal.z), 0.35);

     // needs to be > 2PI
    float randomAngle = 6.28 * interleavedGradientNoise(gl_FragCoord.xy, uFrameModTaaSS);
   
    float invRadius2 = 1.0 / (uSsaoRadius * uSsaoRadius);
    float contrib = 0.0;

    float vv;
    float vn;
    float screenSpaceRadius;
    float angle;
    vec3 occludingPoint;
    vec2 offsetUnitVec;
    int offset = 0;

    float nbSamples = 11.0;
    if (uQuality > 0.33) nbSamples += 11.0;
    if (uQuality > 0.66) nbSamples += 11.0;

    SSAO_DO_TAPS();
    if (uQuality > 0.33) { SSAO_DO_TAPS(); }
    if (uQuality > 0.66) { SSAO_DO_TAPS(); }

    float aoValue = max(0.0, 1.0 - sqrt(contrib * nFalloff / nbSamples));
    aoValue = pow(aoValue, 10.0 * uSsaoIntensity);

    vec4 aoDepth;
    aoDepth.rgb = depthPacked;
    aoDepth.a = mix(1.0, aoValue, clamp(ssRadius - MIN_RADIUS, 0.0, 1.0));

    return aoDepth;
}



void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = ssaoExtract();


    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureSsaoExtract

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME ssaoBlurV

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureBlurInput;
uniform vec2 uTextureInputSize;
uniform vec2 uTextureInputRatio;
uniform vec2 uTextureBlurInputSize;
uniform vec2 uTextureBlurInputRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define SSAO_BLUR_V

#define TEXTURE_2D_TextureBlurInput(uv) (texture2D(TextureBlurInput, (min(uv, 1.0 - 1e+0 / uTextureBlurInputSize.xy)) * uTextureBlurInputRatio))
#define TEXTURE_2D_TextureInput(uv) (vec4(decodeRGBM(texture2D(TextureInput, (min(uv, 1.0 - 1e+0 / uTextureInputSize.xy)) * uTextureInputRatio), uRGBMRange), 1.0))



#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}


#define SSAO_FILTER_RADIUS 3

#define SSAO_TAP_BLUR(id, absid) sampleTex = TEXTURE_2D_TextureBlurInput(uv + axis * float(id) * 2.0);     z = decode24(sampleTex.xyz);     weight = max(0.0, 1.0 - sharpnessFactor * abs(z - initialZ)) * (0.3 + gaussian[absid]);     sum += weight * sampleTex.a;     totalWeight += weight;

vec4 ssaoBlur(const in vec2 axis) {
    vec2 uv = gTexCoord;

    vec4 aoDepth = TEXTURE_2D_TextureBlurInput(uv);

    // background
    if(aoDepth.x == 1.0){
        return aoDepth;
    }

    float initialZ = decode24(aoDepth.xyz);

    float gaussian[SSAO_FILTER_RADIUS + 2]; // dummy because of intel off-by-one bug
    gaussian[0] = 0.153170;
    gaussian[1] = 0.144893;
    gaussian[2] = 0.122649;
    gaussian[3] = 0.092902;
    gaussian[4] = 0.0;

    float totalWeight = gaussian[0];
    float sum = aoDepth.a * totalWeight;
    float sharpnessFactor = 400.0;

    // ---- UNROLL ----
    vec2 ofs;
    float z;
    float weight;
    vec4 sampleTex;

    SSAO_TAP_BLUR(-3, 3);
    SSAO_TAP_BLUR(-2, 2);
    SSAO_TAP_BLUR(-1, 1);
    SSAO_TAP_BLUR(1, 1);
    SSAO_TAP_BLUR(2, 2);
    SSAO_TAP_BLUR(3, 3);
    // ---- UNROLL ----

    aoDepth.a = sum / totalWeight;
    return aoDepth;
}

#ifdef SSAO_BLUR_H
vec4 ssaoBlurH() {
    return ssaoBlur(vec2(1.0, 0.0) / uTextureBlurInputSize);
}
#else
vec4 ssaoBlurV() {
    vec3 color = TEXTURE_2D_TextureInput(gTexCoord).rgb;
    return vec4(color * ssaoBlur(vec2(0.0, 1.0) / uTextureBlurInputSize).aaa, 1.0);
}
#endif


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = ssaoBlurV();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME ssaoBlurV

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureSSSExtract

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureSSSColor;
uniform sampler2D TextureDepth;
uniform vec2 uTextureSSSColorSize;
uniform vec2 uTextureSSSColorRatio;
uniform vec2 uTextureDepthSize;
uniform vec2 uTextureDepthRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureSSSColor(uv) (vec4(decodeRGBM(texture2D(TextureSSSColor, (min(uv, 1.0 - 1e+0 / uTextureSSSColorSize.xy)) * uTextureSSSColorRatio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))



#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}


uniform vec4 uHalton;



// blur jimenez
// https://github.com/iryoku/separable-sss/blob/master/SeparableSSS.h#L454

// blur UE4 (based on jimenez)
// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/SeparableSSS.usf

// UE 4 pre/post passes (down/upsample/checkerboard)
// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/PostProcessSubsurface.usf

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Common.usf#L501
// also solution 2 of http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
float luminanceLinear(const in vec3 color) {
    return dot(color, vec3(0.3, 0.59, 0.11));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/PostProcessSubsurface.usf#L247
void uncheckerboard(out vec3 diffuse, out vec3 specular) {
    vec2 coordCenter = floor(gTexCoord * uTextureSSSColorSize) + 0.5;
    vec2 uvCenter = coordCenter / uTextureSSSColorSize;

    vec3 offset = vec3(1.0 / uTextureSSSColorSize.xy, 0.0);
    vec3 A = TEXTURE_2D_TextureSSSColor(uvCenter + offset.xz).rgb;
    vec3 B = TEXTURE_2D_TextureSSSColor(uvCenter - offset.xz).rgb;
    vec3 C = TEXTURE_2D_TextureSSSColor(uvCenter + offset.zy).rgb;
    vec3 D = TEXTURE_2D_TextureSSSColor(uvCenter - offset.zy).rgb;

    // Luminance could be green channel only
    float a = luminanceLinear(A);
    float b = luminanceLinear(B);
    float c = luminanceLinear(C);
    float d = luminanceLinear(D);

    float ab = abs(a - b);
    float cd = abs(c - d);

    // take the average in the direction that avoids dither pattern
    vec3 quant1 = 0.5 * mix(A + B, C + D, ab > cd ? 1.0 : 0.0);
    vec3 quant0 = TEXTURE_2D_TextureSSSColor(uvCenter).rgb;

    float checker = checkerboard(coordCenter, uHalton);
    diffuse = mix(quant1, quant0, checker);
    specular = mix(quant0, quant1, checker);
}


// hacky line to force the composerPostprocess to
// hook texture funciton in sssCommon because pragma defines
// aren't handled directly

// TEXTURE_2D_TextureSSSColor(whatever)
vec4 sssExtract() {
    vec4 pack = TEXTURE_2D_TextureDepth(gTexCoord);
    vec3 specular;
    vec3 diffuse;
    uncheckerboard(diffuse, specular);

    // force depth "0" to tell sss blur to skip the pixel when blurring
    float bgOrNotSSS = decodeProfile(pack) == 0 || pack.x == 1.0 ? 0.0 : 1.0;

    return vec4(diffuse, bgOrNotSSS * decodeDepth(pack));
}



void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = sssExtract();


    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureSSSExtract

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureSSSBlur1

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureSSSBlur;
uniform sampler2D TextureDepth;
uniform sampler2D TextureSSSKernel;
uniform vec2 uTextureSSSBlurSize;
uniform vec2 uTextureSSSBlurRatio;
uniform vec2 uTextureDepthSize;
uniform vec2 uTextureDepthRatio;
uniform vec2 uTextureSSSKernelSize;
uniform vec2 uTextureSSSKernelRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define SSS_HALF_KERNEL_SIZE 9
#define SSS_PROFILE_COUNT 3
#define SSS_JITTER 1e+0
#define SSS_BYTE_RANGE 1.0

#define TEXTURE_2D_TextureSSSBlur(uv) (texture2D(TextureSSSBlur, (min(uv, 1.0 - 1e+0 / uTextureSSSBlurSize.xy)) * uTextureSSSBlurRatio))
#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))




#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}

// white vs interleaved vs blue noise
// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/

// to test in a shadertoy
// https://www.shadertoy.com/view/lsdfD4

// https://www.shadertoy.com/view/4djSRW
// most combinations are possible : in[1,2,3] -> out[1,2,3]
#define INT_SCALE1 .1031
float pseudoRandom(const in vec2 fragCoord) {
    vec3 p3  = fract(vec3(fragCoord.xyx) * INT_SCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27
float interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MaterialTemplate.ush#L1863
// we slighty change it by multiplying by 1.2 (to match with other noise), otherwise the range seems to be between [0 - 0.83]
float ditheringNoise(const in vec2 fragCoord, const in float frameMod) {
    // float fm = mod(frameMod, 2.0) == 0.0 ? 1.0 : -1.0;
    float fm = frameMod;
    float dither5 = fract((fragCoord.x + fragCoord.y * 2.0 - 1.5 + fm) / 5.0);
    float noise = fract(dot(vec2(171.0, 231.0) / 71.0, fragCoord.xy));
    return (dither5 * 5.0 + noise) * (1.2 / 6.0);
}

//#pragma DECLARE_FUNCTION
void ditheringMaskingDiscard(
    const in vec4 fragCoord,
    const in int dithering,
    const in float alpha,
    const in float factor,

    const in float thinLayer,

    const in float frameMod,
    const in vec2 nearFar,

    const in vec4 halton) {

    if (dithering != 1) {
        if (alpha < factor) discard;
        return;
    }

    float rnd;

    if (thinLayer == 0.0) {
        float linZ = (1.0 / fragCoord.w - nearFar.x) / (nearFar.y - nearFar.x);
        float sliceZ = floor(linZ * 500.0) / 500.0;
        rnd = interleavedGradientNoise(fragCoord.xy + sliceZ, frameMod);
    } else {
        rnd = pseudoRandom(fragCoord.xy + halton.xy * 1000.0 + fragCoord.z * (abs(halton.z) == 2.0 ? 1000.0 : 1.0));
    }

    if (alpha * factor < rnd) discard;
}



uniform vec2 uNearFar;

uniform vec2 uBlurDir;
uniform float uProjFactor;
uniform float uScatteringFactorPacker;
uniform float uFrameModTaaSS;

#ifndef SSS_JITTER
#define SSS_JITTER 1.0
#endif

#ifndef SSS_HALF_KERNEL_SIZE
#define SSS_HALF_KERNEL_SIZE 11
#endif

#ifndef SSS_PROFILE_COUNT
#define SSS_PROFILE_COUNT 1
#endif

#define SSS_FOLLOW_SURFACE

// if we want to do it branchless
vec3 sssFetchColorBranchless(const in vec2 uv, const in vec4 colorM, const in float depthNormBias){
    vec4 fetch = TEXTURE_2D_TextureSSSBlur(uv);

#ifdef SSS_FOLLOW_SURFACE
    float mixer = smoothstep(0.0, 0.05, abs(colorM.a - fetch.a) * depthNormBias);
    mixer = mix(mixer, 1.0, step(fetch.a, 0.0)); // force to 1 if fetch.a is 0 (background)
    fetch.rgb = mix(fetch.rgb, colorM.rgb, mixer);
#endif

    // uv inside box
    // https://stackoverflow.com/questions/12751080/glsl-point-inside-box-test
    vec2 s = step(vec2(0.0), uv) - step(vec2(1.0), uv);
    return mix(colorM.rgb, fetch.rgb, s.x * s.y);
}

vec3 sssFetchColor(const in vec2 uv, const in vec4 colorM, const in float depthNormBias){
    if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0) {
        return colorM.rgb;
    }

    // ignore sss with big depth difference, original jimenez is clamp(dDiff, 0.0, 1.0)
    // we use a much more aggressive function
    vec4 fetch = TEXTURE_2D_TextureSSSBlur(uv);

#ifdef SSS_FOLLOW_SURFACE
    if (fetch.a == 0.0) return colorM.rgb;
    return mix(fetch.rgb, colorM.rgb, smoothstep(0.0, 0.05, abs(colorM.a - fetch.a) * depthNormBias));
#else
    return fetch.rgb;
#endif
}

vec4 sssBlur() {
    vec4 colorM = TEXTURE_2D_TextureSSSBlur(gTexCoord);

    vec4 pack = TEXTURE_2D_TextureDepth(gTexCoord);

    // background or not sss stuffs
    if (pack.x == 1.0) {
        return colorM;
    }

    int profile = decodeProfile(pack);
    float scatter = decodeScatter(pack);
    if (scatter == 0.0) {
        return colorM;
    }

    float scatterWorld = scatter / uScatteringFactorPacker;
    float depthRange = (uNearFar.y - uNearFar.x);

    // for follow surface
    // factor to get a normalized depth difference depending of scatter but not of camera position
    float depthNormBias = depthRange * 0.05 / scatterWorld;

    float worldPos = uNearFar.x + depthRange * colorM.a;
    // uScatteringFactorPacker is just a unpacking factor because subsurface factor 
    // is a world space value but written in 8 bit texture
    vec2 finalStep = uBlurDir * uProjFactor * scatterWorld / worldPos;
    finalStep *= 1.0 / 3.0;

    float yProfile = 1.0 - (float(profile) - 0.5) / float(SSS_PROFILE_COUNT);
    float xKernelSize = 1.0 / float(SSS_HALF_KERNEL_SIZE);

    vec3 kernel0 = texture2D(TextureSSSKernel, vec2(xKernelSize * 0.5, yProfile)).rgb;
    vec3 colorBlurred = colorM.rgb * kernel0;

    // force nearest sample for sss texture kernel color
    vec2 offKernelNearest = vec2(0.5 * xKernelSize, 0.0);

    // randomize the sss texture alpha weight a bit
    float rnd = interleavedGradientNoise(gl_FragCoord.xy, uFrameModTaaSS);
    rnd = mix(0.5, rnd, SSS_JITTER);
    vec2 offKernelJitter = vec2(rnd * xKernelSize, 0.0);

    for (int i = 1; i < SSS_HALF_KERNEL_SIZE; i++) {
        vec2 uvKernel = vec2(float(i) * xKernelSize, yProfile);

        vec3 kernel = texture2D(TextureSSSKernel, uvKernel + offKernelNearest).rgb;
        float kernelDither = texture2D(TextureSSSKernel, uvKernel + offKernelJitter).a;

        vec2 offset = kernelDither * finalStep;

        vec3 fetch = sssFetchColor(gTexCoord + offset, colorM, depthNormBias);
        fetch += sssFetchColor(gTexCoord - offset, colorM, depthNormBias);

        colorBlurred += kernel.rgb * fetch;
    }

    return vec4(colorBlurred, colorM.a);
}



void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = sssBlur();


    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureSSSBlur1

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureSSSBlur2

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureSSSBlur;
uniform sampler2D TextureDepth;
uniform sampler2D TextureSSSKernel;
uniform vec2 uTextureSSSBlurSize;
uniform vec2 uTextureSSSBlurRatio;
uniform vec2 uTextureDepthSize;
uniform vec2 uTextureDepthRatio;
uniform vec2 uTextureSSSKernelSize;
uniform vec2 uTextureSSSKernelRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define SSS_HALF_KERNEL_SIZE 9
#define SSS_PROFILE_COUNT 3
#define SSS_JITTER 1e+0
#define SSS_BYTE_RANGE 1.0

#define TEXTURE_2D_TextureSSSBlur(uv) (texture2D(TextureSSSBlur, (min(uv, 1.0 - 1e+0 / uTextureSSSBlurSize.xy)) * uTextureSSSBlurRatio))
#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))




#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}

// white vs interleaved vs blue noise
// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/

// to test in a shadertoy
// https://www.shadertoy.com/view/lsdfD4

// https://www.shadertoy.com/view/4djSRW
// most combinations are possible : in[1,2,3] -> out[1,2,3]
#define INT_SCALE1 .1031
float pseudoRandom(const in vec2 fragCoord) {
    vec3 p3  = fract(vec3(fragCoord.xyx) * INT_SCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27
float interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/MaterialTemplate.ush#L1863
// we slighty change it by multiplying by 1.2 (to match with other noise), otherwise the range seems to be between [0 - 0.83]
float ditheringNoise(const in vec2 fragCoord, const in float frameMod) {
    // float fm = mod(frameMod, 2.0) == 0.0 ? 1.0 : -1.0;
    float fm = frameMod;
    float dither5 = fract((fragCoord.x + fragCoord.y * 2.0 - 1.5 + fm) / 5.0);
    float noise = fract(dot(vec2(171.0, 231.0) / 71.0, fragCoord.xy));
    return (dither5 * 5.0 + noise) * (1.2 / 6.0);
}

//#pragma DECLARE_FUNCTION
void ditheringMaskingDiscard(
    const in vec4 fragCoord,
    const in int dithering,
    const in float alpha,
    const in float factor,

    const in float thinLayer,

    const in float frameMod,
    const in vec2 nearFar,

    const in vec4 halton) {

    if (dithering != 1) {
        if (alpha < factor) discard;
        return;
    }

    float rnd;

    if (thinLayer == 0.0) {
        float linZ = (1.0 / fragCoord.w - nearFar.x) / (nearFar.y - nearFar.x);
        float sliceZ = floor(linZ * 500.0) / 500.0;
        rnd = interleavedGradientNoise(fragCoord.xy + sliceZ, frameMod);
    } else {
        rnd = pseudoRandom(fragCoord.xy + halton.xy * 1000.0 + fragCoord.z * (abs(halton.z) == 2.0 ? 1000.0 : 1.0));
    }

    if (alpha * factor < rnd) discard;
}



uniform vec2 uNearFar;

uniform vec2 uBlurDir;
uniform float uProjFactor;
uniform float uScatteringFactorPacker;
uniform float uFrameModTaaSS;

#ifndef SSS_JITTER
#define SSS_JITTER 1.0
#endif

#ifndef SSS_HALF_KERNEL_SIZE
#define SSS_HALF_KERNEL_SIZE 11
#endif

#ifndef SSS_PROFILE_COUNT
#define SSS_PROFILE_COUNT 1
#endif

#define SSS_FOLLOW_SURFACE

// if we want to do it branchless
vec3 sssFetchColorBranchless(const in vec2 uv, const in vec4 colorM, const in float depthNormBias){
    vec4 fetch = TEXTURE_2D_TextureSSSBlur(uv);

#ifdef SSS_FOLLOW_SURFACE
    float mixer = smoothstep(0.0, 0.05, abs(colorM.a - fetch.a) * depthNormBias);
    mixer = mix(mixer, 1.0, step(fetch.a, 0.0)); // force to 1 if fetch.a is 0 (background)
    fetch.rgb = mix(fetch.rgb, colorM.rgb, mixer);
#endif

    // uv inside box
    // https://stackoverflow.com/questions/12751080/glsl-point-inside-box-test
    vec2 s = step(vec2(0.0), uv) - step(vec2(1.0), uv);
    return mix(colorM.rgb, fetch.rgb, s.x * s.y);
}

vec3 sssFetchColor(const in vec2 uv, const in vec4 colorM, const in float depthNormBias){
    if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0) {
        return colorM.rgb;
    }

    // ignore sss with big depth difference, original jimenez is clamp(dDiff, 0.0, 1.0)
    // we use a much more aggressive function
    vec4 fetch = TEXTURE_2D_TextureSSSBlur(uv);

#ifdef SSS_FOLLOW_SURFACE
    if (fetch.a == 0.0) return colorM.rgb;
    return mix(fetch.rgb, colorM.rgb, smoothstep(0.0, 0.05, abs(colorM.a - fetch.a) * depthNormBias));
#else
    return fetch.rgb;
#endif
}

vec4 sssBlur() {
    vec4 colorM = TEXTURE_2D_TextureSSSBlur(gTexCoord);

    vec4 pack = TEXTURE_2D_TextureDepth(gTexCoord);

    // background or not sss stuffs
    if (pack.x == 1.0) {
        return colorM;
    }

    int profile = decodeProfile(pack);
    float scatter = decodeScatter(pack);
    if (scatter == 0.0) {
        return colorM;
    }

    float scatterWorld = scatter / uScatteringFactorPacker;
    float depthRange = (uNearFar.y - uNearFar.x);

    // for follow surface
    // factor to get a normalized depth difference depending of scatter but not of camera position
    float depthNormBias = depthRange * 0.05 / scatterWorld;

    float worldPos = uNearFar.x + depthRange * colorM.a;
    // uScatteringFactorPacker is just a unpacking factor because subsurface factor 
    // is a world space value but written in 8 bit texture
    vec2 finalStep = uBlurDir * uProjFactor * scatterWorld / worldPos;
    finalStep *= 1.0 / 3.0;

    float yProfile = 1.0 - (float(profile) - 0.5) / float(SSS_PROFILE_COUNT);
    float xKernelSize = 1.0 / float(SSS_HALF_KERNEL_SIZE);

    vec3 kernel0 = texture2D(TextureSSSKernel, vec2(xKernelSize * 0.5, yProfile)).rgb;
    vec3 colorBlurred = colorM.rgb * kernel0;

    // force nearest sample for sss texture kernel color
    vec2 offKernelNearest = vec2(0.5 * xKernelSize, 0.0);

    // randomize the sss texture alpha weight a bit
    float rnd = interleavedGradientNoise(gl_FragCoord.xy, uFrameModTaaSS);
    rnd = mix(0.5, rnd, SSS_JITTER);
    vec2 offKernelJitter = vec2(rnd * xKernelSize, 0.0);

    for (int i = 1; i < SSS_HALF_KERNEL_SIZE; i++) {
        vec2 uvKernel = vec2(float(i) * xKernelSize, yProfile);

        vec3 kernel = texture2D(TextureSSSKernel, uvKernel + offKernelNearest).rgb;
        float kernelDither = texture2D(TextureSSSKernel, uvKernel + offKernelJitter).a;

        vec2 offset = kernelDither * finalStep;

        vec3 fetch = sssFetchColor(gTexCoord + offset, colorM, depthNormBias);
        fetch += sssFetchColor(gTexCoord - offset, colorM, depthNormBias);

        colorBlurred += kernel.rgb * fetch;
    }

    return vec4(colorBlurred, colorM.a);
}



void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = sssBlur();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureSSSBlur2

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME sssCombine_combineOpacity

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureSSSBlur;
uniform sampler2D TextureSSSColor;
uniform sampler2D TextureDepth;
uniform sampler2D TextureTransparent;
uniform vec2 uTextureSSSBlurSize;
uniform vec2 uTextureSSSBlurRatio;
uniform vec2 uTextureSSSColorSize;
uniform vec2 uTextureSSSColorRatio;
uniform vec2 uTextureDepthSize;
uniform vec2 uTextureDepthRatio;
uniform vec2 uTextureTransparentSize;
uniform vec2 uTextureTransparentRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureSSSColor(uv) (vec4(decodeRGBM(texture2D(TextureSSSColor, (min(uv, 1.0 - 1e+0 / uTextureSSSColorSize.xy)) * uTextureSSSColorRatio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))
#define TEXTURE_2D_TextureSSSBlur(uv) (vec4(decodeRGBM(texture2D(TextureSSSBlur, (min(uv, 1.0 - 1e+0 / uTextureSSSBlurSize.xy)) * uTextureSSSBlurRatio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureTransparent(uv) (texture2D(TextureTransparent, (min(uv, 1.0 - 1e+0 / uTextureTransparentSize.xy)) * uTextureTransparentRatio))



#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}


uniform vec4 uHalton;
uniform vec2 uNearFar;
uniform float uProjFactor;
uniform float uScatteringFactorPacker;



// blur jimenez
// https://github.com/iryoku/separable-sss/blob/master/SeparableSSS.h#L454

// blur UE4 (based on jimenez)
// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/SeparableSSS.usf

// UE 4 pre/post passes (down/upsample/checkerboard)
// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/PostProcessSubsurface.usf

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Common.usf#L501
// also solution 2 of http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
float luminanceLinear(const in vec3 color) {
    return dot(color, vec3(0.3, 0.59, 0.11));
}

// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/PostProcessSubsurface.usf#L247
void uncheckerboard(out vec3 diffuse, out vec3 specular) {
    vec2 coordCenter = floor(gTexCoord * uTextureSSSColorSize) + 0.5;
    vec2 uvCenter = coordCenter / uTextureSSSColorSize;

    vec3 offset = vec3(1.0 / uTextureSSSColorSize.xy, 0.0);
    vec3 A = TEXTURE_2D_TextureSSSColor(uvCenter + offset.xz).rgb;
    vec3 B = TEXTURE_2D_TextureSSSColor(uvCenter - offset.xz).rgb;
    vec3 C = TEXTURE_2D_TextureSSSColor(uvCenter + offset.zy).rgb;
    vec3 D = TEXTURE_2D_TextureSSSColor(uvCenter - offset.zy).rgb;

    // Luminance could be green channel only
    float a = luminanceLinear(A);
    float b = luminanceLinear(B);
    float c = luminanceLinear(C);
    float d = luminanceLinear(D);

    float ab = abs(a - b);
    float cd = abs(c - d);

    // take the average in the direction that avoids dither pattern
    vec3 quant1 = 0.5 * mix(A + B, C + D, ab > cd ? 1.0 : 0.0);
    vec3 quant0 = TEXTURE_2D_TextureSSSColor(uvCenter).rgb;

    float checker = checkerboard(coordCenter, uHalton);
    diffuse = mix(quant1, quant0, checker);
    specular = mix(quant0, quant1, checker);
}



vec4 sssCombine() {
    // full res - not SSS
    vec4 pack = TEXTURE_2D_TextureDepth(gTexCoord);
    int profile = decodeProfile(pack);
    // black pixels for background or non sss surfaces
    if (pack.x == 1.0 || profile == 0) {
        return TEXTURE_2D_TextureSSSColor(gTexCoord);
    }

    vec3 specular;
    vec3 diffuse;
    uncheckerboard(diffuse, specular);

    // try to retain high res detail as much as possible (same ad dof)
    // make sure to use a factor that is independent from bounding box
    float scatterWorld = decodeScatter(pack) / uScatteringFactorPacker;
    float worldPos = uNearFar.x + (uNearFar.y - uNearFar.x) * decodeDepth(pack);
    float factor = uProjFactor * scatterWorld / worldPos;
    
    // magic factor 10 (can be tweaked, e.g: if sss effects disappears too fast when we are far away)
    factor = smoothstep(0.05, 0.3, factor * 10.0);
    // return vec4(vec3(factor), 1.0);

    diffuse = mix(diffuse, TEXTURE_2D_TextureSSSBlur(gTexCoord).rgb, factor);

    return vec4(diffuse + specular, 1.0);
}


vec4 combineOpacity(const in vec4 color) {
    // should be replaced with TEXTURE_2D_TextureTransparent as is can make sense
    vec4 transparent = TEXTURE_2D_TextureTransparent(gTexCoord);
    return vec4(color.rgb * (1.0 - transparent.a) + transparent.rgb, 1.0);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = sssCombine();
    color = combineOpacity(color);

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME sssCombine_combineOpacity

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureBloomExtract

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureDepth;
uniform vec2 uTextureInputSize;
uniform vec2 uTextureInputRatio;
uniform vec2 uTextureDepthSize;
uniform vec2 uTextureDepthRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define HAS_BACKGROUND

#define TEXTURE_2D_TextureInput(uv) (vec4(decodeRGBM(texture2D(TextureInput, (min(uv, 1.0 - 1e+0 / uTextureInputSize.xy)) * uTextureInputRatio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))



#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}


#ifdef HAS_BACKGROUND
#endif

uniform float uBloomThreshold;

vec3 extractBright(const in vec3 color) {
    // TODO manage hdr pixel with high frequency? (use derivative??), for now we clamp the extracted pixel :(
    return clamp(color * clamp(getLuminance(color) - uBloomThreshold, 0.0, 1.0), 0.0, 1.0);
}

vec4 bloomExtract() {
    vec3 color = TEXTURE_2D_TextureInput(gTexCoord).rgb;

#ifdef HAS_BACKGROUND
    float alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));
    if(alpha == 0.0) {
        return vec4(vec3(0.0), 1.0);
    }
#else
    float alpha = 1.0;
#endif

    return vec4(extractBright(color * alpha), 1.0);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = bloomExtract();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureBloomExtract

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureBlurTemp0

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureBlurInput;
uniform vec2 uTextureBlurInputSize;
uniform vec2 uTextureBlurInputRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureBlurInput(uv) (vec4(decodeRGBM(texture2D(TextureBlurInput, (min(uv, 1.0 - 1e+0 / uTextureBlurInputSize.xy)) * uTextureBlurInputRatio), uRGBMRange), 1.0))

uniform vec2 uPixelRatio;
uniform vec2 uBlurDir;

vec4 gaussianBlur() {
    vec3 pixel = 0.375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy).rgb;
    vec2 offset;
    vec2 blurDir = uPixelRatio.xy * uBlurDir.xy / uTextureOutputSize.xy;
    offset = blurDir * 1.2;
    pixel += 0.3125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.3125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    return vec4(pixel, 1.0);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = gaussianBlur();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureBlurTemp0

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureBlurTemp1

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureBlurInput;
uniform vec2 uTextureBlurInputSize;
uniform vec2 uTextureBlurInputRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureBlurInput(uv) (vec4(decodeRGBM(texture2D(TextureBlurInput, (min(uv, 1.0 - 1e+0 / uTextureBlurInputSize.xy)) * uTextureBlurInputRatio), uRGBMRange), 1.0))

uniform vec2 uPixelRatio;
uniform vec2 uBlurDir;

vec4 gaussianBlur() {
    vec3 pixel = 0.3125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy).rgb;
    vec2 offset;
    vec2 blurDir = uPixelRatio.xy * uBlurDir.xy / uTextureOutputSize.xy;
    offset = blurDir * 1.2857142857142858;
    pixel += 0.328125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.328125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    return vec4(pixel, 1.0);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = gaussianBlur();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureBlurTemp1

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureBlurTemp2

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureBlurInput;
uniform vec2 uTextureBlurInputSize;
uniform vec2 uTextureBlurInputRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureBlurInput(uv) (vec4(decodeRGBM(texture2D(TextureBlurInput, (min(uv, 1.0 - 1e+0 / uTextureBlurInputSize.xy)) * uTextureBlurInputRatio), uRGBMRange), 1.0))

uniform vec2 uPixelRatio;
uniform vec2 uBlurDir;

vec4 gaussianBlur() {
    vec3 pixel = 0.2734375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy).rgb;
    vec2 offset;
    vec2 blurDir = uPixelRatio.xy * uBlurDir.xy / uTextureOutputSize.xy;
    offset = blurDir * 1.3333333333333333;
    pixel += 0.328125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.328125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    offset = blurDir * 3.111111111111111;
    pixel += 0.03515625 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.03515625 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    return vec4(pixel, 1.0);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = gaussianBlur();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureBlurTemp2

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureBlurTemp3

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureBlurInput;
uniform vec2 uTextureBlurInputSize;
uniform vec2 uTextureBlurInputRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureBlurInput(uv) (vec4(decodeRGBM(texture2D(TextureBlurInput, (min(uv, 1.0 - 1e+0 / uTextureBlurInputSize.xy)) * uTextureBlurInputRatio), uRGBMRange), 1.0))

uniform vec2 uPixelRatio;
uniform vec2 uBlurDir;

vec4 gaussianBlur() {
    vec3 pixel = 0.24609375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy).rgb;
    vec2 offset;
    vec2 blurDir = uPixelRatio.xy * uBlurDir.xy / uTextureOutputSize.xy;
    offset = blurDir * 1.3636363636363635;
    pixel += 0.322265625 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.322265625 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    offset = blurDir * 3.1818181818181817;
    pixel += 0.0537109375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.0537109375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    return vec4(pixel, 1.0);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = gaussianBlur();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureBlurTemp3

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME TextureBlurTemp4

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureBlurInput;
uniform vec2 uTextureBlurInputSize;
uniform vec2 uTextureBlurInputRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureBlurInput(uv) (vec4(decodeRGBM(texture2D(TextureBlurInput, (min(uv, 1.0 - 1e+0 / uTextureBlurInputSize.xy)) * uTextureBlurInputRatio), uRGBMRange), 1.0))

uniform vec2 uPixelRatio;
uniform vec2 uBlurDir;

vec4 gaussianBlur() {
    vec3 pixel = 0.2255859375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy).rgb;
    vec2 offset;
    vec2 blurDir = uPixelRatio.xy * uBlurDir.xy / uTextureOutputSize.xy;
    offset = blurDir * 1.3846153846153846;
    pixel += 0.314208984375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.314208984375 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    offset = blurDir * 3.230769230769231;
    pixel += 0.06982421875 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.06982421875 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    offset = blurDir * 5.076923076923077;
    pixel += 0.003173828125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy + offset.xy).rgb;
    pixel += 0.003173828125 * TEXTURE_2D_TextureBlurInput(gTexCoord.xy - offset.xy).rgb;
    return vec4(pixel, 1.0);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = gaussianBlur();

    color = encodeRGBM(color.rgb, uRGBMRange);
    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME TextureBlurTemp4

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME bloomCombine_toneMapping

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TextureBloomBlur1;
uniform sampler2D TextureBloomBlur2;
uniform sampler2D TextureBloomBlur3;
uniform sampler2D TextureBloomBlur4;
uniform sampler2D TextureBloomBlur5;
uniform vec2 uTextureInputSize;
uniform vec2 uTextureInputRatio;
uniform vec2 uTextureBloomBlur1Size;
uniform vec2 uTextureBloomBlur1Ratio;
uniform vec2 uTextureBloomBlur2Size;
uniform vec2 uTextureBloomBlur2Ratio;
uniform vec2 uTextureBloomBlur3Size;
uniform vec2 uTextureBloomBlur3Ratio;
uniform vec2 uTextureBloomBlur4Size;
uniform vec2 uTextureBloomBlur4Ratio;
uniform vec2 uTextureBloomBlur5Size;
uniform vec2 uTextureBloomBlur5Ratio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }




#define TEXTURE_2D_TextureBloomBlur1(uv) (vec4(decodeRGBM(texture2D(TextureBloomBlur1, (min(uv, 1.0 - 1e+0 / uTextureBloomBlur1Size.xy)) * uTextureBloomBlur1Ratio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureBloomBlur2(uv) (vec4(decodeRGBM(texture2D(TextureBloomBlur2, (min(uv, 1.0 - 1e+0 / uTextureBloomBlur2Size.xy)) * uTextureBloomBlur2Ratio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureBloomBlur3(uv) (vec4(decodeRGBM(texture2D(TextureBloomBlur3, (min(uv, 1.0 - 1e+0 / uTextureBloomBlur3Size.xy)) * uTextureBloomBlur3Ratio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureBloomBlur4(uv) (vec4(decodeRGBM(texture2D(TextureBloomBlur4, (min(uv, 1.0 - 1e+0 / uTextureBloomBlur4Size.xy)) * uTextureBloomBlur4Ratio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureBloomBlur5(uv) (vec4(decodeRGBM(texture2D(TextureBloomBlur5, (min(uv, 1.0 - 1e+0 / uTextureBloomBlur5Size.xy)) * uTextureBloomBlur5Ratio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureInput(uv) (vec4(decodeRGBM(texture2D(TextureInput, (min(uv, 1.0 - 1e+0 / uTextureInputSize.xy)) * uTextureInputRatio), uRGBMRange), 1.0))
#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))


uniform float uBloomRadius;
uniform float uBloomFactor;

float getRadiusFactored(const float value, const float middle) {
    return mix(value, middle * 2.0 - value, uBloomRadius);
}

vec4 bloomCombine() {
    vec3 bloom = vec3(0.0);

    const float midVal = 0.6;

    const float factor1 = 1.1;
    const float factor2 = 0.9;
    const float factor3 = 0.6;
    const float factor4 = 0.3;
    const float factor5 = 0.1;

    bloom += TEXTURE_2D_TextureBloomBlur1(gTexCoord).rgb * getRadiusFactored(factor1, midVal);
    bloom += TEXTURE_2D_TextureBloomBlur2(gTexCoord).rgb * getRadiusFactored(factor2, midVal);
    bloom += TEXTURE_2D_TextureBloomBlur3(gTexCoord).rgb * getRadiusFactored(factor3, midVal);
    bloom += TEXTURE_2D_TextureBloomBlur4(gTexCoord).rgb * getRadiusFactored(factor4, midVal);
    bloom += TEXTURE_2D_TextureBloomBlur5(gTexCoord).rgb * getRadiusFactored(factor5, midVal);

    vec3 color = TEXTURE_2D_TextureInput(gTexCoord).rgb;
    return vec4(color + (bloom * uBloomFactor), 1.0);
}


#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}

uniform float uToneExposure;
uniform float uToneBrightness;
uniform float uToneContrast;
uniform float uToneSaturation;
uniform int uToneMethod;

#ifdef HAS_FIXED_BACKGROUND
uniform sampler2D TextureDepth;
#endif

vec3 toneMapping(const in vec3 color) {
    vec3 col = color * uToneExposure;
    float luminance = dot(col * (1.0 + uToneBrightness), vec3(0.2126, 0.7152, 0.0722));
    col = mix(vec3(luminance), col * (1.0 + uToneBrightness), vec3(uToneSaturation));

    // contrast is annoying and require special treatment in case of fixed background
    // because it doesn't output black when the input is black
    float toneContrast = uToneContrast;
#ifdef HAS_FIXED_BACKGROUND
    float alpha = decodeAlpha(TEXTURE_2D_TextureDepth(gTexCoord));
    if(alpha == 0.0) toneContrast *= luminance;
#endif
    col = max(vec3(0.0), col * (1.0 + toneContrast) - 0.5 * toneContrast);

    // simple reinhard and filmic
    // http://filmicgames.com/archives/190
    if(uToneMethod == 1) { // reinhard (on luminance)
        col /= 1.0 + getLuminance(col);
    } else if( uToneMethod == 2) { // filmic
        vec3 x = max(vec3(0.0), col - 0.004);
        col = (x * (6.2 * x + 0.5) ) / ( x * (6.2 * x + 1.7) + 0.06);
        col = pow(col, vec3(2.2)); // filmic curve already encode srgb to linear
    }

    return col;
}

vec4 toneMapping(const in vec4 color) {
    return vec4(toneMapping(color.rgb), 1.0);
}



void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = bloomCombine();
    color = toneMapping(color);

    color.rgb = linearTosRGB(color.rgb);

    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME bloomCombine_toneMapping

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
 #else
 precision mediump float;
#endif
attribute vec3 Vertex;
void main(void) {
  gl_Position = vec4(Vertex * 2.0 - 1.0, 1.0);
}

#define SHADER_NAME supersampleTaa

__FRAGMENTSHADER__
#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
 precision highp float;
#else
 precision mediump float;
#endif
uniform float uRGBMRange;
vec2 gTexCoord;
uniform sampler2D TextureInput;
uniform sampler2D TexturePrevious;
uniform sampler2D TextureDepth;
uniform vec2 uTextureInputSize;
uniform vec2 uTextureInputRatio;
uniform vec2 uTexturePreviousSize;
uniform vec2 uTexturePreviousRatio;
uniform vec2 uTextureDepthSize;
uniform vec2 uTextureDepthRatio;
uniform vec2 uTextureOutputSize;
uniform vec2 uTextureOutputRatio;


// approximation such as http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html
// introduced slightly darker colors and more slight banding in the darks.

// so we stick with the reference implementation (except we don't check if color >= 0.0):
// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt
#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055
#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)

//#pragma DECLARE_FUNCTION
float linearTosRGB(const in float color) { return LIN_SRGB(color); }

//#pragma DECLARE_FUNCTION
vec3 linearTosRGB(const in vec3 color) { return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b)); }

//#pragma DECLARE_FUNCTION
vec4 linearTosRGB(const in vec4 color) { return vec4(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b), color.a); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
float sRGBToLinear(const in float color) { return SRGB_LIN(color); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec3 sRGBToLinear(const in vec3 color) { return vec3(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b)); }

//#pragma DECLARE_FUNCTION NODE_NAME:sRGBToLinear
vec4 sRGBToLinear(const in vec4 color) { return vec4(SRGB_LIN(color.r), SRGB_LIN(color.g), SRGB_LIN(color.b), color.a); }

//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
vec3 RGBMToRGB( const in vec4 rgba ) {
    const float maxRange = 8.0;
    return rgba.rgb * maxRange * rgba.a;
}

const mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );

vec3 LUVToRGB( const in vec4 vLogLuv ) {
    float Le = vLogLuv.z * 255.0 + vLogLuv.w;
    vec3 Xp_Y_XYZp;
    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
    vec3 vRGB = LUVInverse * Xp_Y_XYZp;
    return max(vRGB, 0.0);
}

// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html
//#pragma DECLARE_FUNCTION
vec4 encodeRGBM(const in vec3 color, const in float range) {
    if(range <= 0.0) return vec4(color, 1.0);
    vec4 rgbm;
    vec3 col = color / range;
    rgbm.a = clamp( max( max( col.r, col.g ), max( col.b, 1e-6 ) ), 0.0, 1.0 );
    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
    rgbm.rgb = col / rgbm.a;
    return rgbm;
}

//#pragma DECLARE_FUNCTION
vec3 decodeRGBM(const in vec4 color, const in float range) {
    if(range <= 0.0) return color.rgb;
    return range * color.rgb * color.a;
}

// https://twitter.com/pyalot/status/711956736639418369
// https://github.com/mrdoob/three.js/issues/10331
//#pragma DECLARE_FUNCTION NODE_NAME:FrontNormal
#define _frontNormal(normal) gl_FrontFacing ? normal : -normal

//#pragma DECLARE_FUNCTION NODE_NAME:Normalize
#define _normalize(vec) normalize(vec)

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec3 color, const in float alpha) { return vec4(color.rgb * alpha, alpha); }

//#pragma DECLARE_FUNCTION
vec4 preMultAlpha(const in vec4 color) { return vec4(color.rgb * color.a, color.a); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in float alpha) { return vec4(color, alpha); }

//#pragma DECLARE_FUNCTION
vec4 setAlpha(const in vec3 color, const in vec4 alpha) { return vec4(color, alpha.a); }


#define TAA_TRANSPARENT
#define FEEDBACK_MIN 0.88
#define FEEDBACK_MAX 0.97

#define TEXTURE_2D_TextureInput(uv) (texture2D(TextureInput, (min(uv, 1.0 - 1e+0 / uTextureInputSize.xy)) * uTextureInputRatio))
#define TEXTURE_2D_NEAREST_TexturePrevious(uv) (texture2D(TexturePrevious, (floor((min(uv, 1.0 - 1e+0 / uTexturePreviousSize.xy)) * uTexturePreviousSize) + 0.5) * uTexturePreviousRatio / uTexturePreviousSize, -99999.0))
#define TEXTURE_2D_TextureDepth(uv) (texture2D(TextureDepth, (min(uv, 1.0 - 1e+0 / uTextureDepthSize.xy)) * uTextureDepthRatio))
#define TEXTURE_2D_TexturePrevious(uv) (texture2D(TexturePrevious, (min(uv, 1.0 - 1e+0 / uTexturePreviousSize.xy)) * uTexturePreviousRatio))



#define _linTest(color, keepLinear) { return keepLinear == 1 ? color : linearTosRGB(color); }

//#pragma DECLARE_FUNCTION
float linearTosRGBWithTest(const in float color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec3 linearTosRGBWithTest(const in vec3 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
vec4 linearTosRGBWithTest(const in vec4 color, const in int keepLinear) _linTest(color, keepLinear)

//#pragma DECLARE_FUNCTION
float adjustSpecular( const in float specular, const in vec3 normal ) {
    // Based on The Order : 1886 SIGGRAPH course notes implementation (page 21 notes)
    float normalLen = length(normal);
    if ( normalLen < 1.0) {
        float normalLen2 = normalLen * normalLen;
        float kappa = ( 3.0 * normalLen -  normalLen2 * normalLen )/( 1.0 - normalLen2 );
        // http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/
        // page 91 : they use 0.5/kappa instead
        return 1.0-min(1.0, sqrt( (1.0-specular) * (1.0-specular) + 1.0/kappa ));
    }
    return specular;
}

//#pragma DECLARE_FUNCTION
vec3 normalTangentSpace(const in vec4 tangent, const in vec3 normal, const in vec3 texNormal) {
    vec3 tang = vec3(0.0,1.0,0.0);
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // tang =  normalize(tangent.xyz);
        tang =  tangent.xyz / l;
    }
    vec3 B = tangent.w * normalize(cross(normal, tang));
    return normalize( texNormal.x * tang + texNormal.y * B + texNormal.z * normal);
}

//#pragma DECLARE_FUNCTION
vec2 normalMatcap(const in vec3 normal, const in vec3 eyeVector) {
    vec3 nm_x = vec3(-eyeVector.z, 0.0, eyeVector.x);
    vec3 nm_y = cross(nm_x, eyeVector);
    return vec2(dot(normal.xz, -nm_x.xz), dot(normal, nm_y)) * vec2(0.5)  + vec2(0.5);
}

//#pragma DECLARE_FUNCTION
vec3 textureNormalMap(const in vec3 normal, const in int flipY) {
    vec3 rgb = normal * vec3(2.0) + vec3(-1.0); // MADD vec form
    rgb[1] = flipY == 1 ? -rgb[1] : rgb[1];
    return rgb;
}

//#pragma DECLARE_FUNCTION
vec3 bumpMap(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {
    vec3 outnormal;
    float l = length(tangent.xyz);
    if (l != 0.0) {
        //normalize reusing length computations
        // vec3 tang =  normalize(tangent.xyz);
        vec3 tang =  tangent.xyz / l;
        vec3 binormal = tangent.w * normalize(cross(normal, tang));
        outnormal = normal + gradient.x * tang + gradient.y * binormal;
    }
    else {
       outnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);
    }
    return normalize(outnormal);
}

//#pragma DECLARE_FUNCTION
float checkerboard(const in vec2 uv, const in vec4 halton) {
    float taaSwap = step(halton.z, 0.0);
    return mod(taaSwap + floor(uv.x) + floor(uv.y), 2.0);
}

// random links on packing :
// cesium attributes packing
// https://cesiumjs.org/2015/05/18/Vertex-Compression/

// float packing in 24 bits or 32 bits
// https://skytiger.wordpress.com/2010/12/01/packing-depth-into-color/

//#pragma DECLARE_FUNCTION
vec4 encodeDepthAlphaProfileScatter(const in float depth, const in float alpha, const in float profile, const in float scatter) {
    vec4 pack = vec4(0.0);

    // opacity in alpha
    pack.a = alpha;

    if(profile == 0.0) {
        const vec3 code = vec3(1.0, 255.0, 65025.0);
        pack.rgb = vec3(code * depth);
        pack.gb = fract(pack.gb);
        pack.rg -= pack.gb * (1.0 / 256.0);
    } else {
        // depth in rg
        pack.g = fract(depth * 255.0);
        pack.r = depth - pack.g / 255.0;

        // scatter 6 bits
        pack.b = floor(0.5 + scatter * 63.0) * 4.0 / 255.0;
    }

    // profile on 2 lower bits
    pack.b -= mod(pack.b, 4.0 / 255.0);
    pack.b += profile / 255.0; // 3 profile possible for sss

    return pack;
}

int decodeProfile(const in vec4 pack) {
    float packValue = floor(pack.b * 255.0 + 0.5);
    // we extract the 2 lowest bits
    float profile = mod(packValue, 2.0);
    profile += mod(packValue - profile, 4.0);
    return int(profile);
}

float decodeDepth(const in vec4 pack) {
    if(decodeProfile(pack) == 0){
        const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
        return dot(pack.rgb, decode);
    }

    return pack.r + pack.g / 255.0;
}

float decodeScatter(const in vec4 pack) {
    float scatter = pack.b - mod(pack.b, 4.0 / 255.0);
    return scatter * 255.0 / 4.0 / 63.0;
}

float decodeAlpha(const in vec4 pack) {
    return pack.a;
}

float getLuminance(const in vec3 color) {
    // http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
    const vec3 colorBright = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, colorBright);
}

float distanceToDepth(const in sampler2D depth, const in vec2 uv, const in vec4 viewPos, const vec2 nearFar) {
    float fragDepth = clamp( (-viewPos.z * viewPos.w - nearFar.x) / (nearFar.y - nearFar.x), 0.0, 1.0);
    return fragDepth - decodeDepth(texture2D(depth, uv));
}

vec3 encode24(const in float x){
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    vec3 pack = vec3(code * x);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    return pack;
}

float decode24(const in vec3 x) {
    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);
    return dot(x, decode);
}
uniform vec4 uHalton;

uniform float uSSAARestart;

// static in place amortized supersampling
vec4 supersample() {
    vec4 currFragColor = TEXTURE_2D_TextureInput(gTexCoord).rgba;

    float haltz = abs(uHalton.z);
    if (haltz == 1.0) {
        // just return the color.
        return currFragColor;
    }

    // same pixel for same projected interpolated vertex on prev frame
    vec4 accumColorN = TEXTURE_2D_NEAREST_TexturePrevious(gTexCoord).rgba;

    // mix frames
    float lerpFac = 1.0 / uHalton.w;

    // if uTaaSSSRestart is 0.0, then we used the previous TAAed image to start supersampling
    // we do that to avoid a sudden re-aliasing of the image (which is perceptible)
    if (uHalton.w == 1.0) lerpFac = uSSAARestart;

    if (haltz == 3.0) {
        // No supersample, crude motion blur by accumulation
        return mix(currFragColor, accumColorN, lerpFac);
    }

    // Supsersample, accumulation + jittering
    // http://en.wikipedia.org/wiki/Moving_average#Cumulative_moving_average
    // cumulative moving average over frameNum (which starts at 2)
    // n is previous frame
    // accumColorN = Accum(n)
    // return value is accumColor( n +1 )
    // Accum(n+1) = Accum(n) + ((x(n+1) - Accum(n)) / (n + 1)))
    // formula above is equal to glsl  mix
    return mix(accumColorN, currFragColor, lerpFac);
}



uniform vec2 uNearFar;

uniform float uTaaEnabled;
uniform mat4 uTaaInvViewMatrixLeft;
uniform mat4 uTaaCurrentFramePVLeft;
uniform mat4 uTaaLastFramePVLeft;
uniform vec4 uTaaCornersCSLeft[2];

#ifdef VR_ENABLED
uniform mat4 uTaaInvViewMatrixRight;
uniform mat4 uTaaCurrentFramePVRight;
uniform mat4 uTaaLastFramePVRight;
uniform vec4 uTaaCornersCSRight[2];
#endif

vec3 reconstructWSPosition(const in vec2 uv, const in vec4 corners[2], const in mat4 invView, const in float depth) {
    vec2 finalUv = uv;
#ifdef VR_ENABLED
    float xViewportOffset = uv.x >= 0.5 ? -0.5 : 0.0;
    finalUv.x = ( uv.x + xViewportOffset ) * 2.0;
#endif

    // the corners are in view space, it means if we interpolate between them we can retrieve the view space direction of the fragment
    vec4 AB = mix(corners[0], corners[1], finalUv.x);

    // multiply this view space direction by the depth gives us the view space position
    vec3 vsPos = vec3(mix(AB.xy, AB.zw, finalUv.y), 1.0) * depth;

    // multiply by the inverse of the view matrix gives us the world space position
    return (invView * vec4(vsPos, 1.0)).xyz;
}

#define NEIGHBOUR_SET_IF_DMIN_Z_GREATER(d, x, y) if(d < dmin.z) dmin = vec3(x, y, d);
#define NEIGHBOUR_CREATE_FROM_OFFSET(d, x, y) d = decodeDepth(TEXTURE_2D_TextureDepth(uv + vec2(x,y)));
#define FIND_NEIGHBOUR_MIN(d, x, y) NEIGHBOUR_CREATE_FROM_OFFSET(d, x, y); NEIGHBOUR_SET_IF_DMIN_Z_GREATER(d, x, y)


// Neighborhood clamping from Tiago Sousa
// 4tap(decent) comment t, ml, mr, b
// https://github.com/playdeadgames/temporal/blob/9e6a7704e69bb73f29fe393390e545b21ddfd42d/Assets/Shaders/IncDepth.cginc#L111
// 9Tap(good) slower but nicer
// https://github.com/playdeadgames/temporal/blob/9e6a7704e69bb73f29fe393390e545b21ddfd42d/Assets/Shaders/IncDepth.cginc#L37
//#define CLOSEST_9TAP
vec3 closestFragment(const in vec2 uv, const in vec2 texelSize) {

    float d;
    vec2 size = 2.0 * texelSize;
    vec3 dmin = vec3(0.0, 0.0, 0.0);

    // 5Tap
    NEIGHBOUR_CREATE_FROM_OFFSET(dmin.z, 0.0, 0.0);
    FIND_NEIGHBOUR_MIN(d, -size.x, size.y);
    FIND_NEIGHBOUR_MIN(d, size.x, size.y);
    FIND_NEIGHBOUR_MIN(d, -size.x, -size.y);
    FIND_NEIGHBOUR_MIN(d, size.x, -size.y);

#ifdef CLOSEST_9TAP
    FIND_NEIGHBOUR_MIN(d, 0.0, size.y);
    FIND_NEIGHBOUR_MIN(d, -size.x, 0.0);
    FIND_NEIGHBOUR_MIN(d, size.x, 0.0);
    FIND_NEIGHBOUR_MIN(d, 0.0, -size.y);
#endif

    return vec3(uv + dmin.xy, dmin.z);
}

// note: only clips towards aabb center (but fast!)
// same as https://github.com/gokselgoktas/temporal-anti-aliasing/blob/master/Assets/Resources/Shaders/TemporalAntiAliasing.cginc#L199
// which is adapted from https://github.com/playdeadgames/temporal
// using the mathematical similar version of https://twitter.com/Stubbesaurus/status/890154773726580736
// exhibits numerical issue (in a consistent way on intel/nvidia at least)
vec4 clip_aabb_opti(const in vec4 minimum, const in vec4 maximum, const in vec4 color) {
    const float eps = 0.00000001;

    vec4 center = 0.5 * (maximum + minimum);
    vec4 extents = 0.5 * (maximum - minimum) + eps;
    vec4 offset = color - center;

    vec4 ts = abs(offset / extents);
    float t = max(max(ts.r, ts.g), max(ts.b, ts.a));
    return center + offset / max(1.0, t);
    // return t > 1.0 : center + offset / t : color;
}

vec4 taa(const in vec2 ssVel, const in vec2 texelSize) {
    vec2 uv = gTexCoord;

    vec4 tl = TEXTURE_2D_TextureInput(uv + vec2(-texelSize.x, texelSize.y));
    vec4 t  = TEXTURE_2D_TextureInput(uv + vec2(0.0, texelSize.y));
    vec4 tr = TEXTURE_2D_TextureInput(uv + vec2(texelSize.x, texelSize.y));

    vec4 ml = TEXTURE_2D_TextureInput(uv + vec2(-texelSize.x, 0.0));
    vec4 m  = TEXTURE_2D_TextureInput(uv);
    vec4 mr = TEXTURE_2D_TextureInput(uv + vec2(texelSize.x, 0.0));

    vec4 bl = TEXTURE_2D_TextureInput(uv + vec2(-texelSize.x, -texelSize.y));
    vec4 b  = TEXTURE_2D_TextureInput(uv + vec2(0.0, -texelSize.y));
    vec4 br = TEXTURE_2D_TextureInput(uv + vec2(texelSize.x, -texelSize.y));

    // sharpen
    // https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Resources/Shaders/TAA.cginc#L143
    // reduces blurring, but increases flickering with dense geometry
    vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * m;
    m += (m - (corners * 0.166667)) * 2.718282 * 0.3;
    m = max(vec4(0.0), m);

    // Brian Karis neighbourhood rounding: http://advances.realtimerendering.com/s2014/epic/TemporalAA.pptx
    // average of rounded pattern with cross pattern
    vec4 cmin5 = min(mr, min(m, min(ml, min(t, b))));
    vec4 cmin = min(cmin5, min(tl, min(tr, min(bl, br))));

    vec4 cmax5 = max(mr, max(m, max(ml, max(t, b))));
    vec4 cmax = max(cmax5, max(tl, max(tr, max(bl, br))));

    cmin = 0.5 * (cmin + cmin5);
    cmax = 0.5 * (cmax + cmax5);

    vec4 previousColor = TEXTURE_2D_TexturePrevious(uv - ssVel);
    previousColor = clip_aabb_opti(cmin, cmax, previousColor);

    float lum0 = getLuminance(m.rgb);
    float lum1 = getLuminance(previousColor.rgb);
    float diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));
    float unbiased_weight = 1.0 - diff;
    float feedback = mix(FEEDBACK_MIN, FEEDBACK_MAX, unbiased_weight * unbiased_weight);

    return mix(m, previousColor, feedback);
}

vec2 computeSSVelocity(const in vec3 wsPos, const in mat4 currentFrameProjView, const in mat4 lastFrameProjView, const in bool rightEye)
{
    vec4 ssCurrentPos = currentFrameProjView * vec4(wsPos, 1.0);
    vec4 ssPrevPos = lastFrameProjView * vec4(wsPos, 1.0);

    vec2 ndcCurrent = ssCurrentPos.xy / ssCurrentPos.w;
    vec2 ndcPrev = ssPrevPos.xy / ssPrevPos.w;

    //ndcPrev = clamp(ndcPrev, vec2(-1.0), vec2(1.0));
    if(ndcPrev.x >= 1.0 || ndcPrev.x <= -1.0 || ndcPrev.x >= 1.0 || ndcPrev.y <= -1.0)
        return vec2(0.0);

#ifdef VR_ENABLED
    ndcCurrent.x /= 2.0;
    ndcPrev.x /= 2.0;

    if (rightEye) {
        ndcCurrent.x += 0.5;
        ndcPrev.x += 0.5;
    }
#endif

    return 0.5 * (ndcCurrent - ndcPrev);
}


vec4 computeTaa(const in mat4 invView, const in mat4 currentFrameProjView, const in mat4 lastFrameProjView, const in vec4 corners[2]) {
    vec2 uv = gTexCoord;
    float haltz = abs(uHalton.z);
    if (haltz == 1.0) {
        vec2 texelSize = vec2(1.0) / uTextureInputSize;
        vec3 closest = closestFragment(uv, texelSize);

        // discard background fragments to save fillrate
        // make sure the mesh isn't transparent
        if (closest.z >= 1.0
#ifdef TAA_TRANSPARENT
            && decodeAlpha(TEXTURE_2D_TextureDepth(closest.xy)) == 0.0
#endif
        ) {
            // unjitter for fixed background with highres pattern or text
            return TEXTURE_2D_TextureInput(uv - 0.5 * uHalton.xy * texelSize);
        }

        float depth = -(uNearFar.x + (uNearFar.y - uNearFar.x) * closest.z);
        vec3 ws = reconstructWSPosition(closest.xy, corners, invView, depth);

        vec2 ssVel = computeSSVelocity(ws, currentFrameProjView, lastFrameProjView, uv.x >= 0.5);
        return taa(ssVel, texelSize);
    }

    return supersample();
}

// temporal anti-aliasing from Playdead's Inside
// slides: http://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in
// sources: https://github.com/playdeadgames/temporal
vec4 supersampleTaa() {
    if (uTaaEnabled == 0.0) {
        return supersample();
    }

#ifdef VR_ENABLED
    // left and right eyes have different matrices
    if (gTexCoord.x >= 0.5) {
        return computeTaa(uTaaInvViewMatrixRight, uTaaCurrentFramePVRight, uTaaLastFramePVRight, uTaaCornersCSRight);
    }
#endif

    return computeTaa(uTaaInvViewMatrixLeft, uTaaCurrentFramePVLeft, uTaaLastFramePVLeft, uTaaCornersCSLeft);
}


void main() {
    gTexCoord = gl_FragCoord.xy / uTextureOutputSize.xy;
    vec4 color = supersampleTaa();


    gl_FragColor = color;
  gl_FragColor.x += CONST_SHADER_RECACHE;
}

#define SHADER_NAME supersampleTaa

__ENDPROGRAM__
